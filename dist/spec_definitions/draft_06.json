{
  "$copyright": {
    "credits": [
      "IETF Trust <https://www.ietf.org/>",
      "Austin Wright <aaa@bzfx.net>",
      "Henry Andrews <henry@cloudflare.com>",
      "Geraint Luff <luffgd@gmail.com>",
      "Cloudflare, Inc. <https://www.cloudflare.com/>"
    ],
    "year": 2017
  },
  "$docsUrl": "https://json-schema.org/draft-06/json-schema-validation.html",
  "$draft": "6",
  "$license": "BSD-2-Clause License\n\nOriginal source code is copyright (c) 2019-2022 Jeremy Rylan\n<https://github.com/jrylan>\n\nDocumentation and keyword descriptions are copyright (c) 2017 IETF Trust <https://www.ietf.org/>, Austin Wright <aaa@bzfx.net>, Henry Andrews <henry@cloudflare.com>, Geraint Luff <luffgd@gmail.com>, and Cloudflare, Inc. <https://www.cloudflare.com/>. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\n   this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.",
  "$schemaUrl": "http://json-schema.org/draft-06/schema#",
  "enums": {
    "typeName": {
      "description": "Enum consisting of simple type names for the `type` keyword",
      "title": "TypeName",
      "values": {
        "Array": {
          "description": "Value MUST be an array.",
          "value": "array"
        },
        "Boolean": {
          "description": "Value MUST be a boolean.",
          "value": "boolean"
        },
        "Integer": {
          "description": "Value MUST be an integer, no floating point numbers are allowed. This is a subset of the number type.",
          "value": "integer"
        },
        "Null": {
          "description": "Value MUST be null. Note this is mainly for purpose of being able use union types to define nullability. If this type is not included in a union, null values are not allowed (the primitives listed above do not allow nulls on their own).",
          "value": "null"
        },
        "Number": {
          "description": "Value MUST be a number, floating point numbers are allowed.",
          "value": "number"
        },
        "Object": {
          "description": "Value MUST be an object.",
          "value": "object"
        },
        "String": {
          "description": "Value MUST be a string.",
          "value": "string"
        }
      }
    }
  },
  "keywords": {
    "$ref": {
      "description": "The `$ref` keyword is used to reference a schema, and provides the ability\nto validate recursive structures through self-reference.\n\nAn object schema with a `$ref` property MUST be interpreted as a `$ref`\nreference. The value of the `$ref` property MUST be a URI Reference.\nResolved against the current URI base, it identifies the URI of a schema to\nuse. All other properties in a `$ref` object MUST be ignored.\n\nThe URI is not a network locator, only an identifier. A schema need not be\ndownloadable from the address if it is a network-addressable URL, and\nimplementations SHOULD NOT assume they should perform a network operation\nwhen they encounter a network-addressable URI.\n\nA schema MUST NOT be run into an infinite loop against a schema. For\nexample, if two schemas `\"#alice\"` and `\"#bob\"` both have an `allOf`\nproperty that refers to the other, a naive validator might get stuck in an\ninfinite recursive loop trying to validate the instance. Schemas SHOULD NOT\nmake use of infinite recursive nesting like this; the behavior is\nundefined.",
      "format": "uri-reference",
      "type": "string"
    },
    "$schema": {
      "description": "The `$schema` keyword is both used as a JSON Schema version identifier and\nthe location of a resource which is itself a JSON Schema, which describes\nany schema written for this particular version.\n\nThe value of this keyword MUST be a [URI][RFC3986] (containing a scheme)\nand this URI MUST be normalized. The current schema MUST be valid against\nthe meta-schema identified by this URI.\n\nIf this URI identifies a retrievable resource, that resource SHOULD be of\nmedia type `application/schema+json`.\n\nThe `$schema` keyword SHOULD be used in a root schema. It MUST NOT appear\nin subschemas.\n\nValues for this property are defined in other documents and by other\nparties. JSON Schema implementations SHOULD implement support for current\nand previous published drafts of JSON Schema vocabularies as deemed\nreasonable.\n\n[RFC3986]: https://datatracker.ietf.org/doc/html/rfc3986",
      "format": "uri",
      "type": "string"
    },
    "additionalItems": {
      "description": "The value of `additionalItems` MUST be a valid JSON Schema.\n\nThis keyword determines how child instances validate for arrays, and does\nnot directly validate the immediate instance itself.\n\nIf `items` is an array of schemas, validation succeeds if every instance\nelement at a position greater than the size of `items` validates against\n`additionalItems`.\n\nOtherwise, `additionalItems` MUST be ignored, as the `items` schema\n(possibly the default value of an empty schema) is applied to all elements.\n\nOmitting this keyword has the same behavior as an empty schema.",
      "type": "JSONSchema"
    },
    "additionalProperties": {
      "description": "The value of `additionalProperties` MUST be a valid JSON Schema.\n\nThis keyword determines how child instances validate for objects, and does\nnot directly validate the immediate instance itself.\n\nValidation with `additionalProperties` applies only to the child values of\ninstance names that do not match any names in `properties`, and do not\nmatch any regular expression in `patternProperties`.\n\nFor all such properties, validation succeeds if the child instance\nvalidates against the `additionalProperties` schema.\n\nOmitting this keyword has the same behavior as an empty schema.",
      "type": "JSONSchema"
    },
    "allOf": {
      "description": "This keyword's value MUST be a non-empty array. Each item of the array MUST\nbe a valid JSON Schema.\n\nAn instance validates successfully against this keyword if it validates\nsuccessfully against all schemas defined by this keyword's value.",
      "items": {
        "type": "JSONSchema<Narrowable>"
      },
      "type": "array"
    },
    "anyOf": {
      "description": "This keyword's value MUST be a non-empty array. Each item of the array MUST\nbe a valid JSON Schema.\n\nAn instance validates successfully against this keyword if it validates\nsuccessfully against at least one schema defined by this keyword's value.",
      "items": {
        "type": "JSONSchema<Narrowable>"
      },
      "type": "array"
    },
    "contains": {
      "description": "The value of this keyword MUST be a valid JSON Schema.\n\nAn array instance is valid against `contains` if at least one of its\nelements is valid against the given schema.",
      "type": "JSONSchema<Narrowable>"
    },
    "default": {
      "description": "This keyword can be used to supply a default JSON value associated with a\nparticular schema. It is RECOMMENDED that a `default` value be valid\nagainst the associated schema.",
      "type": "Value"
    },
    "definitions": {
      "additionalProperties": {
        "type": "JSONSchema"
      },
      "description": "The `definitions` keywords provides a standardized location for schema\nauthors to inline re-usable JSON Schemas into a more general schema. The\nkeyword does not directly affect the validation result.\n\nThis keyword's value MUST be an object. Each member value of this object\nMUST be a valid JSON Schema.",
      "type": "object"
    },
    "dependencies": {
      "description": "This keyword specifies rules that are evaluated if the instance is an\nobject and contains a certain property.\n\nThis keyword's value MUST be an object. Each property specifies a\ndependency. Each dependency value MUST be an array or a valid JSON Schema.\n\nIf the dependency value is a subschema, and the dependency key is a\nproperty in the instance, the entire instance must validate against the\ndependency value.\n\nIf the dependency value is an array, each element in the array, if any,\nMUST be a string, and MUST be unique. If the dependency key is a property\nin the instance, each of the items in the dependency value must be a\nproperty that exists in the instance.\n\nOmitting this keyword has the same behavior as an empty object.",
      "oneOf": [
        {
          "additionalProperties": {
            "oneOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "JSONSchema"
              }
            ]
          },
          "type": "object"
        }
      ]
    },
    "description": {
      "description": "Can be used to decorate a user interface with explanation or information\nabout the data produced.",
      "type": "string"
    },
    "enum": {
      "description": "The value of this keyword MUST be an array. This array SHOULD have at least\none element. Elements in the array SHOULD be unique.\n\nAn instance validates successfully against this keyword if its value is\nequal to one of the elements in this keyword's array value.\n\nElements in the array might be of any type, including `null`.",
      "items": {
        "type": "Value"
      },
      "type": "array"
    },
    "examples": {
      "description": "The value of this keyword MUST be an array. There are no restrictions on\nthe items in the array.\n\nThis keyword can be used to provide sample JSON values associated with a\nparticular schema, for the purpose of illustrating usage. It is RECOMMENDED\nthat these values be valid against the associated schema.\n\nImplementations MAY use the value(s) of `default`, if present, as an\nadditional example. If `examples` is absent, `default` MAY still be used in\nthis manner.",
      "items": {
        "type": "Value"
      },
      "type": "array"
    },
    "exclusiveMaximum": {
      "description": "The value of `exclusiveMaximum` MUST be a number, representing an exclusive\nupper limit for a numeric instance.\n\nIf the instance is a number, then the instance is valid only if it has a\nvalue strictly less than (not equal to) `exclusiveMaximum`.",
      "type": "number"
    },
    "exclusiveMinimum": {
      "description": "The value of `exclusiveMinimum` MUST be a number, representing an exclusive\nlower limit for a numeric instance.\n\nIf the instance is a number, then the instance is valid only if it has a\nvalue strictly greater than (not equal to) `exclusiveMinimum`.",
      "type": "number"
    },
    "format": {
      "description": "The `format` keyword functions as both an [annotation][annotation] and as\nan [assertion][assertion]. While no special effort is required to implement\nit as an annotation conveying semantic meaning, implementing validation is\nnon-trivial.\n\nImplementations MAY support the `format` keyword as a validation assertion.\n\nImplementations MAY add custom `format` attributes. Save for agreement\nbetween parties, schema authors SHALL NOT expect a peer implementation to\nsupport this keyword and/or custom `format` attributes.\n\n[annotation]: https://json-schema.org/draft-06/json-schema-validation.html#annotations\n[assertion]: https://json-schema.org/draft-06/json-schema-validation.html#assertions",
      "type": "string"
    },
    "items": {
      "description": "The value of `items` MUST be either a valid JSON Schema or an array of\nvalid JSON Schemas.\n\nThis keyword determines how child instances validate for arrays, and does\nnot directly validate the immediate instance itself.\n\nIf `items` is a schema, validation succeeds if all elements in the array\nsuccessfully validate against that schema.\n\nIf `items` is an array of schemas, validation succeeds if each element of\nthe instance validates against the schema at the same position, if any.\n\nOmitting this keyword has the same behavior as an empty schema.",
      "oneOf": [
        {
          "items": {
            "type": "JSONSchema"
          },
          "type": "array"
        },
        {
          "type": "JSONSchema"
        }
      ]
    },
    "maximum": {
      "description": "The value of `maximum` MUST be a number, representing an inclusive upper\nlimit for a numeric instance.\n\nIf the instance is a number, then this keyword validates only if the\ninstance is less than or exactly equal to `maximum`.",
      "type": "number"
    },
    "maxItems": {
      "description": "The value of this keyword MUST be a non-negative integer.\n\nAn array instance is valid against `maxItems` if its size is less than, or\nequal to, the value of this keyword.",
      "minimum": 0,
      "type": "integer"
    },
    "maxLength": {
      "description": "The value of this keyword MUST be a non-negative integer.\n\nA string instance is valid against this keyword if its length is less than,\nor equal to, the value of this keyword.\n\nThe length of a string instance is defined as the number of its characters\nas defined by [RFC 7159][RFC7159].\n\n[RFC7159]: https://datatracker.ietf.org/doc/html/rfc7159",
      "minimum": 0,
      "type": "integer"
    },
    "maxProperties": {
      "description": "The value of this keyword MUST be a non-negative integer.\n\nAn object instance is valid against `maxProperties` if its number of\n`properties` is less than, or equal to, the value of this keyword.",
      "minimum": 0,
      "type": "integer"
    },
    "minimum": {
      "description": "The value of `minimum` MUST be a number, representing an inclusive lower\nlimit for a numeric instance.\n\nIf the instance is a number, then this keyword validates only if the\ninstance is greater than or exactly equal to `minimum`.",
      "type": "number"
    },
    "minItems": {
      "default": 0,
      "description": "The value of this keyword MUST be a non-negative integer.\n\nAn array instance is valid against `minItems` if its size is greater than,\nor equal to, the value of this keyword.\n\nOmitting this keyword has the same behavior as a value of `0`.",
      "minimum": 0,
      "type": "integer"
    },
    "minLength": {
      "default": 0,
      "description": "The value of this keyword MUST be a non-negative integer.\n\nA string instance is valid against this keyword if its length is greater\nthan, or equal to, the value of this keyword.\n\nThe length of a string instance is defined as the number of its characters\nas defined by [RFC 7159][RFC7159].\n\nOmitting this keyword has the same behavior as a value of `0`.\n\n[RFC7159]: https://datatracker.ietf.org/doc/html/rfc7159",
      "minimum": 0,
      "type": "integer"
    },
    "minProperties": {
      "default": 0,
      "description": "The value of this keyword MUST be a non-negative integer.\n\nAn object instance is valid against `minProperties` if its number of\n`properties` is greater than, or equal to, the value of this keyword.\n\nOmitting this keyword has the same behavior as a value of `0`.",
      "minimum": 0,
      "type": "integer"
    },
    "multipleOf": {
      "description": "The value of `multipleOf` MUST be a number, strictly greater than `0`.\n\nA numeric instance is valid only if division by this keyword's value\nresults in an integer.",
      "exclusiveMinimum": 0,
      "type": "number"
    },
    "not": {
      "description": "This keyword's value MUST be a valid JSON Schema.\n\nAn instance is valid against this keyword if it fails to validate\nsuccessfully against the schema defined by this keyword.",
      "type": "JSONSchema<Narrowable>"
    },
    "oneOf": {
      "description": "This keyword's value MUST be a non-empty array. Each item of the array MUST\nbe a valid JSON Schema.\n\nAn instance validates successfully against this keyword if it validates\nsuccessfully against exactly one schema defined by this keyword's value.",
      "items": {
        "type": "JSONSchema<Narrowable>"
      },
      "type": "array"
    },
    "pattern": {
      "description": "The value of this keyword MUST be a string. This string SHOULD be a valid\nregular expression, according to the [ECMA-262][ecma262] regular expression\ndialect.\n\nA string instance is considered valid if the regular expression matches the\ninstance successfully. Recall: regular expressions are not implicitly\nanchored.\n\n[ecma262]: https://www.ecma-international.org/publications-and-standards/standards/ecma-262/",
      "format": "regex",
      "type": "string"
    },
    "patternProperties": {
      "additionalProperties": {
        "type": "JSONSchema"
      },
      "description": "The value of `patternProperties` MUST be an object. Each property name of\nthis object SHOULD be a valid regular expression, according to the\n[ECMA-262][ecma262] regular expression dialect. Each property value of this\nobject MUST be a valid JSON Schema.\n\nThis keyword determines how child instances validate for objects, and does\nnot directly validate the immediate instance itself. Validation of the\nprimitive instance type against this keyword always succeeds.\n\nValidation succeeds if, for each instance name that matches any regular\nexpressions that appear as a property name in this keyword's value, the\nchild instance for that name successfully validates against each schema\nthat corresponds to a matching regular expression.\n\nOmitting this keyword has the same behavior as an empty object.\n\n[ecma262]: https://www.ecma-international.org/publications-and-standards/standards/ecma-262/",
      "type": "object"
    },
    "properties": {
      "additionalProperties": {
        "type": "JSONSchema"
      },
      "description": "The value of `properties` MUST be an object. Each value of this object MUST\nbe a valid JSON Schema.\n\nThis keyword determines how child instances validate for objects, and does\nnot directly validate the immediate instance itself.\n\nValidation succeeds if, for each name that appears in both the instance and\nas a name within this keyword's value, the child instance for that name\nsuccessfully validates against the corresponding schema.\n\nOmitting this keyword has the same behavior as an empty object.",
      "type": "object"
    },
    "propertyNames": {
      "description": "The value of `propertyNames` MUST be a valid JSON Schema.\n\nIf the instance is an object, this keyword validates if every property name\nin the instance validates against the provided schema. Note the property\nname that the schema is testing will always be a string.\n\nOmitting this keyword has the same behavior as an empty schema.",
      "type": "JSONSchema"
    },
    "required": {
      "description": "The value of this keyword MUST be an array. Elements of this array, if any,\nMUST be strings, and MUST be unique.\n\nAn object instance is valid against this keyword if every item in the array\nis the name of a property in the instance.\n\nOmitting this keyword has the same behavior as an empty array.",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "title": {
      "description": "Can be used to decorate a user interface with a short label about the data\nproduced.",
      "type": "string"
    },
    "type": {
      "description": "The value of this keyword MUST be either a string or an array. If it is an\narray, elements of the array MUST be strings and MUST be unique.\n\nString values MUST be one of the six primitive types (`\"null\"`,\n`\"boolean\"`, `\"object\"`, `\"array\"`, `\"number\"`, or `\"string\"`), or\n`\"integer\"` which matches any number with a zero fractional part.\n\nAn instance validates if and only if the instance is in any of the sets\nlisted for this keyword.",
      "oneOf": [
        {
          "enum": [
            "array",
            "boolean",
            "integer",
            "null",
            "number",
            "object",
            "string"
          ],
          "type": "string"
        },
        {
          "items": {
            "enum": [
              "array",
              "boolean",
              "integer",
              "null",
              "number",
              "object",
              "string"
            ],
            "type": "string"
          },
          "type": "array"
        }
      ]
    },
    "uniqueItems": {
      "default": false,
      "description": "The value of this keyword MUST be a boolean.\n\nIf this keyword has boolean value `false`, the instance validates\nsuccessfully. If it has boolean value `true`, the instance validates\nsuccessfully if all of its elements are unique.\n\nOmitting this keyword has the same behavior as a value of `false`.",
      "type": "boolean"
    }
  },
  "keywordsByType": {
    "any": {
      "title": "Any",
      "values": [
        "$ref",
        "$schema",
        "allOf",
        "anyOf",
        "default",
        "definitions",
        "description",
        "enum",
        "examples",
        "not",
        "oneOf",
        "title",
        "type"
      ]
    },
    "array": {
      "title": "Array",
      "values": [
        "additionalItems",
        "contains",
        "items",
        "maxItems",
        "minItems",
        "uniqueItems"
      ]
    },
    "number": {
      "title": "Number",
      "values": [
        "exclusiveMaximum",
        "exclusiveMinimum",
        "maximum",
        "minimum",
        "multipleOf"
      ]
    },
    "object": {
      "title": "Object",
      "values": [
        "additionalProperties",
        "dependencies",
        "maxProperties",
        "minProperties",
        "patternProperties",
        "properties",
        "propertyNames",
        "required"
      ]
    },
    "string": {
      "title": "String",
      "values": [
        "format",
        "maxLength",
        "minLength",
        "pattern"
      ]
    }
  }
}