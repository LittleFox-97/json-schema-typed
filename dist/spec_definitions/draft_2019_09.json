{
  "$copyright": {
    "credits": [
      "IETF Trust <https://www.ietf.org/>",
      "Austin Wright <aaa@bzfx.net>",
      "Henry Andrews <andrews_henry@yahoo.com>",
      "Ben Hutton <bh7@sanger.ac.uk>",
      "Greg Dennis <gregsdennis@yahoo.com>"
    ],
    "year": 2019
  },
  "$docsUrl": "https://json-schema.org/draft/2019-09/json-schema-validation.html",
  "$draft": "2019-09",
  "$license": "BSD-2-Clause License\n\nOriginal source code is copyright (c) 2022 Jeremy Rylan\n<https://github.com/jrylan>\n\nDocumentation and keyword descriptions are copyright (c) 2019 IETF Trust <https://www.ietf.org/>, Austin Wright <aaa@bzfx.net>, Henry Andrews <andrews_henry@yahoo.com>, Ben Hutton <bh7@sanger.ac.uk>, and Greg Dennis <gregsdennis@yahoo.com>. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\n   this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.",
  "$schemaUrl": "https://json-schema.org/draft/2019-09/schema",
  "enums": {
    "contentEncoding": {
      "description": "Content encoding strategy enum.\n\n- [Content-Transfer-Encoding Syntax](https://datatracker.ietf.org/doc/html/rfc2045#section-6.1)\n- [7bit vs 8bit encoding](https://stackoverflow.com/questions/25710599/content-transfer-encoding-7bit-or-8-bit/28531705#28531705)",
      "title": "ContentEncoding",
      "values": {
        "7bit": {
          "description": "Only US-ASCII characters, which use the lower 7 bits for each character.\n\nEach line must be less than 1,000 characters.",
          "value": "7bit"
        },
        "8bit": {
          "description": "Allow extended ASCII characters which can use the 8th (highest) bit to indicate special characters not available in 7bit.\n\nEach line must be less than 1,000 characters.",
          "value": "8bit"
        },
        "Base64": {
          "description": "Useful for data that is mostly non-text.",
          "value": "base64"
        },
        "Binary": {
          "description": "Same character set as 8bit, with no line length restriction.",
          "value": "binary"
        },
        "IETFToken": {
          "description": "An extension token defined by a standards-track RFC and registered with IANA.",
          "value": "ietf-token"
        },
        "QuotedPrintable": {
          "description": "Lines are limited to 76 characters, and line breaks are represented using special characters that are escaped.",
          "value": "quoted-printable"
        },
        "XToken": {
          "description": "The two characters \"X-\" or \"x-\" followed, with no intervening white space, by any token.",
          "value": "x-token"
        }
      }
    },
    "format": {
      "description": "This enum provides well-known formats that apply to strings.",
      "title": "Format",
      "values": {
        "Date": {
          "description": "A string instance is valid against this attribute if it is a valid representation according to the \"full-date\" production in [RFC 3339][RFC3339].\n\n[RFC3339]: https://datatracker.ietf.org/doc/html/rfc3339",
          "value": "date"
        },
        "DateTime": {
          "description": "A string instance is valid against this attribute if it is a valid representation according to the \"date-time\" production in [RFC 3339][RFC3339].\n\n[RFC3339]: https://datatracker.ietf.org/doc/html/rfc3339",
          "value": "date-time"
        },
        "Duration": {
          "description": "A string instance is valid against this attribute if it is a valid representation according to the \"duration\" production.",
          "value": "duration"
        },
        "Email": {
          "description": "A string instance is valid against this attribute if it is a valid Internet email address as defined by [RFC 5322, section 3.4.1][RFC5322].\n\n[RFC5322]: https://datatracker.ietf.org/doc/html/rfc5322",
          "value": "email"
        },
        "Hostname": {
          "description": "As defined by [RFC 1123, section 2.1][RFC1123], including host names produced using the Punycode algorithm specified in [RFC 5891, section 4.4][RFC5891].\n\n[RFC1123]: https://datatracker.ietf.org/doc/html/rfc1123\n[RFC5891]: https://datatracker.ietf.org/doc/html/rfc5891",
          "value": "hostname"
        },
        "IDNEmail": {
          "description": "A string instance is valid against this attribute if it is a valid Internet email address as defined by [RFC 6531][RFC6531].\n\n[RFC6531]: https://datatracker.ietf.org/doc/html/rfc6531",
          "value": "idn-email"
        },
        "IDNHostname": {
          "description": "As defined by either [RFC 1123, section 2.1][RFC1123] as for hostname, or an internationalized hostname as defined by [RFC 5890, section 2.3.2.3][RFC5890].\n\n[RFC1123]: https://datatracker.ietf.org/doc/html/rfc1123\n[RFC5890]: https://datatracker.ietf.org/doc/html/rfc5890",
          "value": "idn-hostname"
        },
        "IPv4": {
          "description": "An IPv4 address according to the \"dotted-quad\" ABNF syntax as defined in [RFC 2673, section 3.2][RFC2673].\n\n[RFC2673]: https://datatracker.ietf.org/doc/html/rfc2673",
          "value": "ipv4"
        },
        "IPv6": {
          "description": "An IPv6 address as defined in [RFC 4291, section 2.2][RFC4291].\n\n[RFC4291]: https://datatracker.ietf.org/doc/html/rfc4291",
          "value": "ipv6"
        },
        "IRI": {
          "description": "A string instance is valid against this attribute if it is a valid IRI, according to [RFC 3987][RFC3987].\n\n[RFC3987]: https://datatracker.ietf.org/doc/html/rfc3987",
          "value": "iri"
        },
        "IRIReference": {
          "description": "A string instance is valid against this attribute if it is a valid IRI Reference (either an IRI or a relative-reference), according to [RFC 3987][RFC3987].\n\n[RFC3987]: https://datatracker.ietf.org/doc/html/rfc3987",
          "value": "iri-reference"
        },
        "JSONPointer": {
          "description": "A string instance is valid against this attribute if it is a valid JSON string representation of a JSON Pointer, according to [RFC 6901, section 5][RFC6901].\n\n[RFC6901]: https://datatracker.ietf.org/doc/html/rfc6901",
          "value": "json-pointer"
        },
        "JSONPointerURIFragment": {
          "description": "A string instance is valid against this attribute if it is a valid JSON string representation of a JSON Pointer fragment, according to [RFC 6901, section 5][RFC6901].\n\n[RFC6901]: https://datatracker.ietf.org/doc/html/rfc6901",
          "value": "json-pointer-uri-fragment"
        },
        "RegEx": {
          "description": "This attribute applies to string instances.\n\nA regular expression, which SHOULD be valid according to the [ECMA-262][ecma262] regular expression dialect.\n\nImplementations that validate formats MUST accept at least the subset of [ECMA-262][ecma262] defined in the [Regular Expressions][regexInterop] section of this specification, and SHOULD accept all valid [ECMA-262][ecma262] expressions.\n\n[ecma262]: https://www.ecma-international.org/publications-and-standards/standards/ecma-262/\n[regexInterop]: https://json-schema.org/draft/2019-09/json-schema-validation.html#regexInterop",
          "value": "regex"
        },
        "RelativeJSONPointer": {
          "description": "A string instance is valid against this attribute if it is a valid [Relative JSON Pointer][relative-json-pointer].\n\n[relative-json-pointer]: https://datatracker.ietf.org/doc/html/draft-handrews-relative-json-pointer-01",
          "value": "relative-json-pointer"
        },
        "Time": {
          "description": "A string instance is valid against this attribute if it is a valid representation according to the \"time\" production in [RFC 3339][RFC3339].\n\n[RFC3339]: https://datatracker.ietf.org/doc/html/rfc3339",
          "value": "time"
        },
        "URI": {
          "description": "A string instance is valid against this attribute if it is a valid URI, according to [RFC3986][RFC3986].\n\n[RFC3986]: https://datatracker.ietf.org/doc/html/rfc3986",
          "value": "uri"
        },
        "URIReference": {
          "description": "A string instance is valid against this attribute if it is a valid URI Reference (either a URI or a relative-reference), according to [RFC3986][RFC3986].\n\n[RFC3986]: https://datatracker.ietf.org/doc/html/rfc3986",
          "value": "uri-reference"
        },
        "URITemplate": {
          "description": "A string instance is valid against this attribute if it is a valid URI Template (of any level), according to [RFC 6570][RFC6570].\n\nNote that URI Templates may be used for IRIs; there is no separate IRI Template specification.\n\n[RFC6570]: https://datatracker.ietf.org/doc/html/rfc6570",
          "value": "uri-template"
        },
        "UUID": {
          "description": "A string instance is valid against this attribute if it is a valid string representation of a UUID, according to [RFC 4122][RFC4122].\n\n[RFC4122]: https://datatracker.ietf.org/doc/html/rfc4122",
          "value": "uuid"
        }
      }
    },
    "typeName": {
      "description": "Enum consisting of simple type names for the `type` keyword",
      "title": "TypeName",
      "values": {
        "Array": {
          "description": "Value MUST be an array.",
          "value": "array"
        },
        "Boolean": {
          "description": "Value MUST be a boolean.",
          "value": "boolean"
        },
        "Integer": {
          "description": "Value MUST be an integer, no floating point numbers are allowed. This is a subset of the number type.",
          "value": "integer"
        },
        "Null": {
          "description": "Value MUST be null. Note this is mainly for purpose of being able use union types to define nullability. If this type is not included in a union, null values are not allowed (the primitives listed above do not allow nulls on their own).",
          "value": "null"
        },
        "Number": {
          "description": "Value MUST be a number, floating point numbers are allowed.",
          "value": "number"
        },
        "Object": {
          "description": "Value MUST be an object.",
          "value": "object"
        },
        "String": {
          "description": "Value MUST be a string.",
          "value": "string"
        }
      }
    }
  },
  "keywords": {
    "$anchor": {
      "description": "Using JSON Pointer fragments requires knowledge of the structure of the\nschema. When writing schema documents with the intention to provide\nre-usable schemas, it may be preferable to use a plain name fragment that\nis not tied to any particular structural location. This allows a subschema\nto be relocated without requiring JSON Pointer references to be updated.\n\nThe `$anchor` keyword is used to specify such a fragment. It is an\nidentifier keyword that can only be used to create plain name fragments.\n\nIf present, the value of this keyword MUST be a string, which MUST start\nwith a letter `[A-Za-z]`, followed by any number of letters, digits\n`[0-9]`, hyphens `-`, underscores `_`, colons `:`, or periods `.`.\n\nNote that the anchor string does not include the `#` character, as it is\nnot a URI-reference. An `{\"$anchor\": \"foo\"}` becomes the fragment `#foo`\nwhen used in a URI.\n\nThe base URI to which the resulting fragment is appended is determined by\nthe `$id` keyword as explained in the previous section. Two `$anchor`\nkeywords in the same schema document MAY have the same value if they apply\nto different base URIs, as the resulting full URIs will be distinct.\nHowever, the effect of two `$anchor` keywords with the same value and the\nsame base URI is undefined. Implementations MAY raise an error if such\nusage is detected.",
      "type": "string"
    },
    "$comment": {
      "description": "This keyword reserves a location for comments from schema authors to\nreaders or maintainers of the schema.\n\nThe value of this keyword MUST be a string. Implementations MUST NOT\npresent this string to end users. Tools for editing schemas SHOULD support\ndisplaying and editing this keyword. The value of this keyword MAY be used\nin debug or error output which is intended for developers making use of\nschemas.\n\nSchema vocabularies SHOULD allow `$comment` within any object containing\nvocabulary keywords. Implementations MAY assume `$comment` is allowed\nunless the vocabulary specifically forbids it. Vocabularies MUST NOT\nspecify any effect of `$comment` beyond what is described in this\nspecification.\n\nTools that translate other media types or programming languages to and from\n`application/schema+json` MAY choose to convert that media type or\nprogramming language's native comments to or from `$comment` values. The\nbehavior of such translation when both native comments and `$comment`\nproperties are present is implementation-dependent.\n\nImplementations SHOULD treat `$comment` identically to an unknown extension\nkeyword. They MAY strip `$comment` values at any point during processing.\nIn particular, this allows for shortening schemas when the size of deployed\nschemas is a concern.\n\nImplementations MUST NOT take any other action based on the presence,\nabsence, or contents of `$comment` properties. In particular, the value of\n`$comment` MUST NOT be collected as an annotation result.",
      "type": "string"
    },
    "$defs": {
      "additionalProperties": {
        "type": "JSONSchema"
      },
      "description": "The `$defs` keywords provides a standardized location for schema authors to\ninline re-usable JSON Schemas into a more general schema. The keyword does\nnot directly affect the validation result.\n\nThis keyword's value MUST be an object. Each member value of this object\nMUST be a valid JSON Schema.",
      "type": "object"
    },
    "$id": {
      "description": "The `$id` keyword identifies a schema resource with its\n[canonical][[RFC6596]] URI.\n\nNote that this URI is an identifier and not necessarily a network locator.\nIn the case of a network-addressable URL, a schema need not be downloadable\nfrom its canonical URI.\n\nIf present, the value for this keyword MUST be a string, and MUST represent\na valid [URI-reference][RFC3986]. This URI-reference SHOULD be normalized,\nand MUST resolve to an [absolute-URI][RFC3986] (without a fragment).\nTherefore, `$id` MUST NOT contain a non-empty fragment, and SHOULD NOT\ncontain an empty fragment.\n\nSince an empty fragment in the context of the `application/schema+json`\nmedia type refers to the same resource as the base URI without a fragment,\nan implementation MAY normalize a URI ending with an empty fragment by\nremoving the fragment. However, schema authors SHOULD NOT rely on this\nbehavior across implementations.\n\nThis URI also serves as the base URI for relative URI-references in\nkeywords within the schema resource, in accordance with [RFC 3986][RFC3986]\nsection 5.1.1 regarding base URIs embedded in content.\n\nThe presence of `$id` in a subschema indicates that the subschema\nconstitutes a distinct schema resource within a single schema document.\nFurthermore, in accordance with [RFC 3986][RFC3986] section 5.1.2 regarding\nencapsulating entities, if an `$id` in a subschema is a relative\nURI-reference, the base URI for resolving that reference is the URI of the\nparent schema resource.\n\nIf no parent schema object explicitly identifies itself as a resource with\n`$id`, the base URI is that of the entire document.\n\nThe root schema of a JSON Schema document SHOULD contain an `$id` keyword\nwith an [absolute-URI][RFC3986] (containing a scheme, but no fragment).\n\n[RFC6596]: https://datatracker.ietf.org/doc/html/rfc6596\n[RFC3986]: https://datatracker.ietf.org/doc/html/rfc3986",
      "format": "uri-reference",
      "type": "string"
    },
    "$recursiveAnchor": {
      "description": "The value of the `$recursiveAnchor` property MUST be a boolean.\n\n`$recursiveAnchor` is used to dynamically identify a base URI at runtime\nfor `$recursiveRef` by marking where such a calculation can start, and\nwhere it stops. This keyword MUST NOT affect the base URI of other\nkeywords, unless they are explicitly defined to rely on it.\n\nIf set to `true`, then when the containing schema object is used as a\ntarget of `$recursiveRef`, a new base URI is determined by examining the\n[dynamic scope][scopes] for the outermost schema that also contains\n`$recursiveAnchor` with a value of `true`. The base URI of that schema is\nthen used as the dynamic base URI.\n\n- If no such schema exists, then the base URI is unchanged.\n- If this keyword is set to `false`, the base URI is unchanged.\n\nOmitting this keyword has the same behavior as a value of `false`.\n\n[scopes]: https://json-schema.org/draft/2019-09/json-schema-core.html#scopes",
      "type": "boolean"
    },
    "$recursiveRef": {
      "description": "The value of the `$recursiveRef` property MUST be a string which is a\nURI-reference. It is a by-reference applicator that uses a dynamically\ncalculated base URI to resolve its value.\n\nThe behavior of this keyword is defined only for the value `\"#\"`.\nImplementations MAY choose to consider other values to be errors.\n\nThe value of `$recursiveRef` is initially resolved against the current base\nURI, in the same manner as for `$ref`.\n\nThe schema identified by the resulting URI is examined for the presence of\n`$recursiveAnchor`, and a new base URI is calculated.\n\nFinally, the value of `$recursiveRef` is resolved against the new base URI\ndetermined according to `$recursiveAnchor` producing the final resolved\nreference URI.\n\nNote that in the absence of `$recursiveAnchor` (and in some cases when it\nis present), `$recursiveRef`'s behavior is identical to that of `$ref`.\n\nAs with `$ref`, the results of this keyword are the results of the\nreferenced schema.",
      "format": "uri-reference",
      "type": "string"
    },
    "$ref": {
      "description": "The `$ref` keyword is an applicator that is used to reference a statically\nidentified schema. Its results are the results of the referenced schema.\nOther keywords can appear alongside of `$ref` in the same schema object.\n\nThe value of the `$ref` property MUST be a string which is a URI-Reference.\nResolved against the current URI base, it produces the URI of the schema to\napply.",
      "format": "uri-reference",
      "type": "string"
    },
    "$schema": {
      "description": "The `$schema` keyword is both used as a JSON Schema version identifier and\nthe location of a resource which is itself a JSON Schema, which describes\nany schema written for this particular version.\n\nThe value of this keyword MUST be a [URI][RFC3986] (containing a scheme)\nand this URI MUST be normalized. The current schema MUST be valid against\nthe meta-schema identified by this URI.\n\nIf this URI identifies a retrievable resource, that resource SHOULD be of\nmedia type `application/schema+json`.\n\nThe `$schema` keyword SHOULD be used in a resource root schema. It MUST NOT\nappear in resource subschemas. If absent from the root schema, the\nresulting behavior is implementation-defined.\n\nIf multiple schema resources are present in a single document, then all\nschema resources SHOULD Have the same value for `$schema`. The result of\ndiffering values for \"$schema\" within the same schema document is\nimplementation-defined.\n\nValues for this property are defined elsewhere in this and other documents,\nand by other parties.\n\n[RFC3986]: https://datatracker.ietf.org/doc/html/rfc3986",
      "format": "uri",
      "type": "string"
    },
    "$vocabulary": {
      "additionalProperties": {
        "format": "uri",
        "type": "string"
      },
      "description": "The `$vocabulary` keyword is used in meta-schemas to identify the\nvocabularies available for use in schemas described by that meta-schema. It\nis also used to indicate whether each vocabulary is required or optional,\nin the sense that an implementation MUST understand the required\nvocabularies in order to successfully process the schema.\n\nThe value of this keyword MUST be an object. The property names in the\nobject MUST be URIs (containing a scheme) and this URI MUST be normalized.\nEach URI that appears as a property name identifies a specific set of\nkeywords and their semantics.\n\nThe URI MAY be a URL, but the nature of the retrievable resource is\ncurrently undefined, and reserved for future use. Vocabulary authors MAY\nuse the URL of the vocabulary specification, in a human-readable media type\nsuch as `text/html` or `text/plain`, as the vocabulary URI.\n\nThe values of the object properties MUST be booleans. If the value is\n`true`, then implementations that do not recognize the vocabulary MUST\nrefuse to process any schemas that declare this meta-schema with \"$schema\".\nIf the value is `false`, implementations that do not recognize the\nvocabulary SHOULD proceed with processing such schemas.\n\nUnrecognized keywords SHOULD be ignored. This remains the case for keywords\ndefined by unrecognized vocabularies. It is not currently possible to\ndistinguish between unrecognized keywords that are defined in vocabularies\nfrom those that are not part of any vocabulary.\n\nThe `$vocabulary` keyword SHOULD be used in the root schema of any schema\ndocument intended for use as a meta-schema. It MUST NOT appear in\nsubschemas.\n\nThe `$vocabulary` keyword MUST be ignored in schema documents that are not\nbeing processed as a meta-schema.",
      "type": "object"
    },
    "additionalItems": {
      "description": "The value of `additionalItems` MUST be a valid JSON Schema.\n\nThe behavior of this keyword depends on the presence and annotation result\nof `items` within the same schema object. If `items` is present, and its\nannotation result is a number, validation succeeds if every instance\nelement at an index greater than that number validates against\n`additionalItems`.\n\nOtherwise, if `items` is absent or its annotation result is the boolean\n`true`, `additionalItems` MUST be ignored.\n\nIf the `additionalItems` subschema is applied to any positions within the\ninstance array, it produces an annotation result of boolean `true`,\nanalogous to the single schema behavior of `items`. If any\n`additionalItems` keyword from any subschema applied to the same instance\nlocation produces an annotation value of `true`, then the combined result\nfrom these keywords is also `true`.\n\nOmitting this keyword has the same assertion behavior as an empty schema.\n\nImplementations MAY choose to implement or optimize this keyword in another\nway that produces the same effect, such as by directly checking for the\npresence and size of an `items` array.",
      "type": "JSONSchema"
    },
    "additionalProperties": {
      "description": "The value of `additionalProperties` MUST be a valid JSON Schema.\n\nThe behavior of this keyword depends on the presence and annotation results\nof `properties` and `patternProperties` within the same schema object.\nValidation with `additionalProperties` applies only to the child values of\ninstance names that do not appear in the annotation results of either\n`properties` or `patternProperties`.\n\nFor all such properties, validation succeeds if the child instance\nvalidates against the `additionalProperties` schema.\n\nThe annotation result of this keyword is the set of instance property names\nvalidated by this keyword's subschema. Annotation results for\n`additionalProperties` keywords from multiple schemas applied to the same\ninstance location are combined by taking the union of the sets.\n\nOmitting this keyword has the same assertion behavior as an empty schema.\n\nImplementations MAY choose to implement or optimize this keyword in another\nway that produces the same effect, such as by directly checking the names\nin `properties` and the patterns in `patternProperties` against the\ninstance property set.",
      "type": "JSONSchema"
    },
    "allOf": {
      "description": "This keyword's value MUST be a non-empty array. Each item of the array MUST\nbe a valid JSON Schema.\n\nAn instance validates successfully against this keyword if it validates\nsuccessfully against all schemas defined by this keyword's value.",
      "items": {
        "type": "JSONSchema<Narrowable>"
      },
      "type": "array"
    },
    "anyOf": {
      "description": "This keyword's value MUST be a non-empty array. Each item of the array MUST\nbe a valid JSON Schema.\n\nAn instance validates successfully against this keyword if it validates\nsuccessfully against at least one schema defined by this keyword's value.",
      "items": {
        "type": "JSONSchema<Narrowable>"
      },
      "type": "array"
    },
    "const": {
      "description": "An instance validates successfully against this keyword if its value is\nequal to the value of the keyword.\n\nUse of this keyword is functionally equivalent to the `enum` keyword with a\nsingle value.",
      "type": "Value"
    },
    "contains": {
      "description": "An array instance is valid against `contains` if at least one of its\nelements is valid against the given schema. Note that when collecting\nannotations, the subschema MUST be applied to every array element even\nafter the first match has been found. This is to ensure that all possible\nannotations are collected.",
      "type": "JSONSchema<Narrowable>"
    },
    "contentEncoding": {
      "description": "If the instance value is a string, this property defines that the string\nSHOULD be interpreted as binary data and decoded using the encoding named\nby this property. [RFC 2045, Sec 6.1][RFC2045] lists the possible values\nfor this property.\n\nThe value of this property SHOULD be ignored if the instance described is\nnot a string.\n\nIf this keyword is absent, but `contentMediaType` is present, this\nindicates that the media type could be encoded into `UTF-8` like any other\nJSON string value, and does not require additional decoding.\n\nThe value of this property MUST be a string.\n\n[RFC2045]: https://datatracker.ietf.org/doc/html/rfc2045#section-6.1",
      "enum": [
        "7bit",
        "8bit",
        "base64",
        "binary",
        "ietf-token",
        "quoted-printable",
        "x-token"
      ],
      "type": "string"
    },
    "contentMediaType": {
      "description": "If the instance is a string, this property indicates the media type of the\ncontents of the string. If `contentEncoding` is present, this property\ndescribes the decoded string.\n\nThe value of this property must be a media type, as defined by\n[RFC 2046][RFC2046]. This property defines the media type of instances\nwhich this schema defines.\n\nThe value of this property SHOULD be ignored if the instance described is\nnot a string.\n\nIf the `contentEncoding` property is not present, but the instance value is\na string, then the value of this property SHOULD specify a text document\ntype, and the character set SHOULD be the character set into which the JSON\nstring value was decoded (for which the default is Unicode).\n\n[RFC2046]: https://datatracker.ietf.org/doc/html/rfc2046",
      "type": "string"
    },
    "contentSchema": {
      "description": "If the instance is a string, and if `contentMediaType` is present, this\nproperty contains a schema which describes the structure of the string.\n\nThis keyword MAY be used with any media type that can be mapped into JSON\nSchema's data model.\n\nThe value of this property SHOULD be ignored if `contentMediaType` is not\npresent.",
      "type": "JSONSchema<Narrowable>"
    },
    "default": {
      "description": "This keyword can be used to supply a default JSON value associated with a\nparticular schema. It is RECOMMENDED that a `default` value be valid\nagainst the associated schema.",
      "type": "Value"
    },
    "definitions": {
      "additionalProperties": {
        "type": "JSONSchema"
      },
      "deprecated": "`definitions` has been renamed to `$defs`.",
      "type": "object"
    },
    "dependencies": {
      "deprecated": "`dependencies` has been split into two keywords:\n`dependentSchemas` and `dependentRequired`.",
      "oneOf": [
        {
          "additionalProperties": {
            "oneOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "JSONSchema"
              }
            ]
          },
          "type": "object"
        }
      ]
    },
    "dependentRequired": {
      "additionalProperties": {
        "items": {
          "type": "string"
        },
        "type": "array"
      },
      "description": "The value of this keyword MUST be an object. Properties in this object, if\nany, MUST be arrays. Elements in each array, if any, MUST be strings, and\nMUST be unique.\n\nThis keyword specifies properties that are required if a specific other\nproperty is present. Their requirement is dependent on the presence of the\nother property.\n\nValidation succeeds if, for each name that appears in both the instance and\nas a name within this keyword's value, every item in the corresponding\narray is also the name of a property in the instance.\n\nOmitting this keyword has the same behavior as an empty object.",
      "type": "object"
    },
    "dependentSchemas": {
      "additionalProperties": {
        "type": "JSONSchema"
      },
      "description": "This keyword specifies subschemas that are evaluated if the instance is an\nobject and contains a certain property.\n\nThis keyword's value MUST be an object. Each value in the object MUST be a\nvalid JSON Schema.\n\nIf the object key is a property in the instance, the entire instance must\nvalidate against the subschema. Its use is dependent on the presence of the\nproperty.\n\nOmitting this keyword has the same behavior as an empty object.",
      "type": "object"
    },
    "deprecated": {
      "description": "The value of this keyword MUST be a boolean. When multiple occurrences of\nthis keyword are applicable to a single sub-instance, applications SHOULD\nconsider the instance location to be deprecated if any occurrence specifies\na `true` value.\n\nIf `deprecated` has a value of boolean `true`, it indicates that\napplications SHOULD refrain from usage of the declared property. It MAY\nmean the property is going to be removed in the future.\n\nA root schema containing `deprecated` with a value of `true` indicates that\nthe entire resource being described MAY be removed in the future.\n\nWhen the `deprecated` keyword is applied to an item in an array by means of\n`items`, if `items` is a single schema, the deprecation relates to the\nwhole array, while if `items` is an array of schemas, the deprecation\nrelates to the corresponding item according to the subschemas position.\n\nOmitting this keyword has the same behavior as a value of `false`.",
      "type": "boolean"
    },
    "description": {
      "description": "Can be used to decorate a user interface with explanation or information\nabout the data produced.",
      "type": "string"
    },
    "else": {
      "description": "This keyword's value MUST be a valid JSON Schema.\n\nWhen `if` is present, and the instance fails to validate against its\nsubschema, then validation succeeds against this keyword if the instance\nsuccessfully validates against this keyword's subschema.\n\nThis keyword has no effect when `if` is absent, or when the instance\nsuccessfully validates against its subschema. Implementations MUST NOT\nevaluate the instance against this keyword, for either validation or\nannotation collection purposes, in such cases.",
      "type": "JSONSchema<Narrowable>"
    },
    "enum": {
      "description": "The value of this keyword MUST be an array. This array SHOULD have at least\none element. Elements in the array SHOULD be unique.\n\nAn instance validates successfully against this keyword if its value is\nequal to one of the elements in this keyword's array value.\n\nElements in the array might be of any type, including `null`.",
      "items": {
        "type": "Value"
      },
      "type": "array"
    },
    "examples": {
      "description": "The value of this keyword MUST be an array. When multiple occurrences of\nthis keyword are applicable to a single sub-instance, implementations MUST\nprovide a flat array of all values rather than an array of arrays.\n\nThis keyword can be used to provide sample JSON values associated with a\nparticular schema, for the purpose of illustrating usage. It is RECOMMENDED\nthat these values be valid against the associated schema.\n\nImplementations MAY use the value(s) of `default`, if present, as an\nadditional example. If `examples` is absent, `default` MAY still be used in\nthis manner.",
      "items": {
        "type": "Value"
      },
      "type": "array"
    },
    "exclusiveMaximum": {
      "description": "The value of `exclusiveMaximum` MUST be a number, representing an exclusive\nupper limit for a numeric instance.\n\nIf the instance is a number, then the instance is valid only if it has a\nvalue strictly less than (not equal to) `exclusiveMaximum`.",
      "type": "number"
    },
    "exclusiveMinimum": {
      "description": "The value of `exclusiveMinimum` MUST be a number, representing an exclusive\nlower limit for a numeric instance.\n\nIf the instance is a number, then the instance is valid only if it has a\nvalue strictly greater than (not equal to) `exclusiveMinimum`.",
      "type": "number"
    },
    "format": {
      "description": "Implementations MAY treat `format` as an assertion in addition to an\nannotation, and attempt to validate the value's conformance to the\nspecified semantics.\n\nThe value of this keyword is called a format attribute. It MUST be a\nstring. A format attribute can generally only validate a given set of\ninstance types. If the type of the instance to validate is not in this set,\nvalidation for this format attribute and instance SHOULD succeed. Format\nattributes are most often applied to strings, but can be specified to apply\nto any type.\n\nImplementations MAY support custom format attributes. Save for agreement\nbetween parties, schema authors SHALL NOT expect a peer implementation to\nsupport such custom format attributes. An implementation MUST NOT fail\nvalidation or cease processing due to an unknown format attribute. When\ntreating `format` as an annotation, implementations SHOULD collect both\nknown and unknown format attribute values.",
      "type": "string"
    },
    "if": {
      "description": "This keyword's value MUST be a valid JSON Schema.\n\nThis validation outcome of this keyword's subschema has no direct effect on\nthe overall validation result. Rather, it controls which of the `then` or\n`else` keywords are evaluated.\n\nInstances that successfully validate against this keyword's subschema MUST\nalso be valid against the subschema value of the `then` keyword, if\npresent.\n\nInstances that fail to validate against this keyword's subschema MUST also\nbe valid against the subschema value of the `else` keyword, if present.\n\nIf annotations are being collected, they are collected from this keyword's\nsubschema in the usual way, including when the keyword is present without\neither `then` or `else`.",
      "type": "JSONSchema<Narrowable>"
    },
    "items": {
      "description": "The value of `items` MUST be either a valid JSON Schema or an array of\nvalid JSON Schemas.\n\nIf `items` is a schema, validation succeeds if all elements in the array\nsuccessfully validate against that schema.\n\nIf `items` is an array of schemas, validation succeeds if each element of\nthe instance validates against the schema at the same position, if any.\n\nThis keyword produces an annotation value which is the largest index to\nwhich this keyword applied a subschema. The value MAY be a boolean `true`\nif a subschema was applied to every index of the instance, such as when\n`items` is a schema.\n\nAnnotation results for `items` keywords from multiple schemas applied to\nthe same instance location are combined by setting the combined result to\n`true` if any of the values are `true`, and otherwise retaining the largest\nnumerical value.\n\nOmitting this keyword has the same assertion behavior as an empty schema.",
      "oneOf": [
        {
          "items": {
            "type": "JSONSchema"
          },
          "type": "array"
        },
        {
          "type": "JSONSchema"
        }
      ]
    },
    "maxContains": {
      "description": "The value of this keyword MUST be a non-negative integer.\n\nAn array instance is valid against `maxContains` if the number of elements\nthat are valid against the schema for `contains` is less than, or equal to,\nthe value of this keyword.\n\nIf `contains` is not present within the same schema object, then this\nkeyword has no effect.",
      "type": "integer"
    },
    "maximum": {
      "description": "The value of `maximum` MUST be a number, representing an inclusive upper\nlimit for a numeric instance.\n\nIf the instance is a number, then this keyword validates only if the\ninstance is less than or exactly equal to `maximum`.",
      "type": "number"
    },
    "maxItems": {
      "description": "The value of this keyword MUST be a non-negative integer.\n\nAn array instance is valid against `maxItems` if its size is less than, or\nequal to, the value of this keyword.",
      "minimum": 0,
      "type": "integer"
    },
    "maxLength": {
      "description": "The value of this keyword MUST be a non-negative integer.\n\nA string instance is valid against this keyword if its length is less than,\nor equal to, the value of this keyword.\n\nThe length of a string instance is defined as the number of its characters\nas defined by [RFC 8259][RFC8259].\n\n[RFC8259]: https://datatracker.ietf.org/doc/html/rfc8259",
      "minimum": 0,
      "type": "integer"
    },
    "maxProperties": {
      "description": "The value of this keyword MUST be a non-negative integer.\n\nAn object instance is valid against `maxProperties` if its number of\n`properties` is less than, or equal to, the value of this keyword.",
      "minimum": 0,
      "type": "integer"
    },
    "minContains": {
      "default": 1,
      "description": "The value of this keyword MUST be a non-negative integer.\n\nAn array instance is valid against `minContains` if the number of elements\nthat are valid against the schema for `contains` is greater than, or equal\nto, the value of this keyword.\n\nA value of `0` is allowed, but is only useful for setting a range of\noccurrences from `0` to the value of `maxContains`. A value of `0` with no\n`maxContains` causes `contains` to always pass validation.\n\nIf `contains` is not present within the same schema object, then this\nkeyword has no effect.\n\nOmitting this keyword has the same behavior as a value of `1`.",
      "type": "integer"
    },
    "minimum": {
      "description": "The value of `minimum` MUST be a number, representing an inclusive lower\nlimit for a numeric instance.\n\nIf the instance is a number, then this keyword validates only if the\ninstance is greater than or exactly equal to `minimum`.",
      "type": "number"
    },
    "minItems": {
      "default": 0,
      "description": "The value of this keyword MUST be a non-negative integer.\n\nAn array instance is valid against `minItems` if its size is greater than,\nor equal to, the value of this keyword.\n\nOmitting this keyword has the same behavior as a value of `0`.",
      "minimum": 0,
      "type": "integer"
    },
    "minLength": {
      "default": 0,
      "description": "The value of this keyword MUST be a non-negative integer.\n\nA string instance is valid against this keyword if its length is greater\nthan, or equal to, the value of this keyword.\n\nThe length of a string instance is defined as the number of its characters\nas defined by [RFC 8259][RFC8259].\n\nOmitting this keyword has the same behavior as a value of `0`.\n\n[RFC8259]: https://datatracker.ietf.org/doc/html/rfc8259",
      "minimum": 0,
      "type": "integer"
    },
    "minProperties": {
      "default": 0,
      "description": "The value of this keyword MUST be a non-negative integer.\n\nAn object instance is valid against `minProperties` if its number of\n`properties` is greater than, or equal to, the value of this keyword.\n\nOmitting this keyword has the same behavior as a value of `0`.",
      "minimum": 0,
      "type": "integer"
    },
    "multipleOf": {
      "description": "The value of `multipleOf` MUST be a number, strictly greater than `0`.\n\nA numeric instance is valid only if division by this keyword's value\nresults in an integer.",
      "exclusiveMinimum": 0,
      "type": "number"
    },
    "not": {
      "description": "This keyword's value MUST be a valid JSON Schema.\n\nAn instance is valid against this keyword if it fails to validate\nsuccessfully against the schema defined by this keyword.",
      "type": "JSONSchema<Narrowable>"
    },
    "oneOf": {
      "description": "This keyword's value MUST be a non-empty array. Each item of the array MUST\nbe a valid JSON Schema.\n\nAn instance validates successfully against this keyword if it validates\nsuccessfully against exactly one schema defined by this keyword's value.",
      "items": {
        "type": "JSONSchema<Narrowable>"
      },
      "type": "array"
    },
    "pattern": {
      "description": "The value of this keyword MUST be a string. This string SHOULD be a valid\nregular expression, according to the [ECMA-262][ecma262] regular expression\ndialect.\n\nA string instance is considered valid if the regular expression matches the\ninstance successfully. Recall: regular expressions are not implicitly\nanchored.\n\n[ecma262]: https://www.ecma-international.org/publications-and-standards/standards/ecma-262/",
      "format": "regex",
      "type": "string"
    },
    "patternProperties": {
      "additionalProperties": {
        "type": "JSONSchema"
      },
      "description": "The value of `patternProperties` MUST be an object. Each property name of\nthis object SHOULD be a valid regular expression, according to the\n[ECMA-262][ecma262] regular expression dialect. Each property value of this\nobject MUST be a valid JSON Schema.\n\nValidation succeeds if, for each instance name that matches any regular\nexpressions that appear as a property name in this keyword's value, the\nchild instance for that name successfully validates against each schema\nthat corresponds to a matching regular expression.\n\nThe annotation result of this keyword is the set of instance property names\nmatched by this keyword. Annotation results for `patternProperties`\nkeywords from multiple schemas applied to the same instance location are\ncombined by taking the union of the sets.\n\nOmitting this keyword has the same assertion behavior as an empty object.\n\n[ecma262]: https://www.ecma-international.org/publications-and-standards/standards/ecma-262/",
      "type": "object"
    },
    "properties": {
      "additionalProperties": {
        "type": "JSONSchema"
      },
      "description": "The value of `properties` MUST be an object. Each value of this object MUST\nbe a valid JSON Schema.\n\nValidation succeeds if, for each name that appears in both the instance and\nas a name within this keyword's value, the child instance for that name\nsuccessfully validates against the corresponding schema.\n\nThe annotation result of this keyword is the set of instance property names\nmatched by this keyword. Annotation results for `properties` keywords from\nmultiple schemas applied to the same instance location are combined by\ntaking the union of the sets.\n\nOmitting this keyword has the same assertion behavior as an empty object.",
      "type": "object"
    },
    "propertyNames": {
      "description": "The value of `propertyNames` MUST be a valid JSON Schema.\n\nIf the instance is an object, this keyword validates if every property name\nin the instance validates against the provided schema. Note the property\nname that the schema is testing will always be a string.\n\nOmitting this keyword has the same behavior as an empty schema.",
      "type": "JSONSchema"
    },
    "readOnly": {
      "default": false,
      "description": "The value of this keyword MUST be a boolean. When multiple occurrences of\nthis keyword are applicable to a single sub-instance, the resulting value\nMUST be `true` if any occurrence specifies a `true` value, and MUST be\n`false` otherwise.\n\nIf `readOnly` has a value of boolean `true`, it indicates that the value of\nthe instance is managed exclusively by the owning authority, and attempts\nby an application to modify the value of this property are expected to be\nignored or rejected by that owning authority.\n\nAn instance document that is marked as `readOnly` for the entire document\nMAY be ignored if sent to the owning authority, or MAY result in an error,\nat the authority's discretion.\n\nFor example, `readOnly` would be used to mark a database-generated serial\nnumber as read-only.\n\nThis keyword can be used to assist in user interface instance generation.",
      "type": "boolean"
    },
    "required": {
      "description": "The value of this keyword MUST be an array. Elements of this array, if any,\nMUST be strings, and MUST be unique.\n\nAn object instance is valid against this keyword if every item in the array\nis the name of a property in the instance.\n\nOmitting this keyword has the same behavior as an empty array.",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "then": {
      "description": "This keyword's value MUST be a valid JSON Schema.\n\nWhen `if` is present, and the instance successfully validates against its\nsubschema, then validation succeeds against this keyword if the instance\nalso successfully validates against this keyword's subschema.\n\nThis keyword has no effect when `if` is absent, or when the instance fails\nto validate against its subschema. Implementations MUST NOT evaluate the\ninstance against this keyword, for either validation or annotation\ncollection purposes, in such cases.",
      "type": "JSONSchema<Narrowable>"
    },
    "title": {
      "description": "Can be used to decorate a user interface with a short label about the data\nproduced.",
      "type": "string"
    },
    "type": {
      "description": "The value of this keyword MUST be either a string or an array. If it is an\narray, elements of the array MUST be strings and MUST be unique.\n\nString values MUST be one of the six primitive types (`\"null\"`,\n`\"boolean\"`, `\"object\"`, `\"array\"`, `\"number\"`, or `\"string\"`), or\n`\"integer\"` which matches any number with a zero fractional part.\n\nAn instance validates if and only if the instance is in any of the sets\nlisted for this keyword.",
      "oneOf": [
        {
          "enum": [
            "array",
            "boolean",
            "integer",
            "null",
            "number",
            "object",
            "string"
          ],
          "type": "string"
        },
        {
          "items": {
            "enum": [
              "array",
              "boolean",
              "integer",
              "null",
              "number",
              "object",
              "string"
            ],
            "type": "string"
          },
          "type": "array"
        }
      ]
    },
    "unevaluatedItems": {
      "description": "The value of `unevaluatedItems` MUST be a valid JSON Schema.\n\nThe behavior of this keyword depends on the annotation results of adjacent\nkeywords that apply to the instance location being validated. Specifically,\nthe annotations from `items` and `additionalItems`, which can come from\nthose keywords when they are adjacent to the `unevaluatedItems` keyword.\nThose two annotations, as well as `unevaluatedItems`, can also result from\nany and all adjacent [in-place applicator][in-place-applicator] keywords.\n\nIf an `items` annotation is present, and its annotation result is a number,\nand no \"additionalItems\" or `unevaluatedItems` annotation is present, then\nvalidation succeeds if every instance element at an index greater than the\n`items` annotation validates against `unevaluatedItems`.\n\nOtherwise, if any `items`, `additionalItems`, or `unevaluatedItems`\nannotations are present with a value of boolean `true`, then\n`unevaluatedItems` MUST be ignored. However, if none of these annotations\nare present, `unevaluatedItems` MUST be applied to all locations in the\narray.\n\nThis means that `items`, `additionalItems`, and all in-place applicators\nMUST be evaluated before this keyword can be evaluated. Authors of\nextension keywords MUST NOT define an in-place applicator that would need\nto be evaluated before this keyword.\n\nIf the `unevaluatedItems` subschema is applied to any positions within the\ninstance array, it produces an annotation result of boolean `true`,\nanalogous to the single schema behavior of `items`. If any\n`unevaluatedItems` keyword from any subschema applied to the same instance\nlocation produces an annotation value of `true`, then the combined result\nfrom these keywords is also `true`.\n\nOmitting this keyword has the same assertion behavior as an empty schema.\n\nImplementations that do not collect annotations MUST raise an error upon\nencountering this keyword.\n\n[in-place-applicator]: https://json-schema.org/draft/2019-09/json-schema-core.html#in-place",
      "type": "JSONSchema"
    },
    "unevaluatedProperties": {
      "description": "The value of `unevaluatedProperties` MUST be a valid JSON Schema.\n\nThe behavior of this keyword depends on the annotation results of adjacent\nkeywords that apply to the instance location being validated. Specifically,\nthe annotations from `properties`, `patternProperties`, and\n`additionalProperties`, which can come from those keywords when they are\nadjacent to the `unevaluatedProperties` keyword. Those three annotations,\nas well as `unevaluatedProperties`, can also result from any and all\nadjacent [in-place applicator][in-place-applicator] keywords.\n\nValidation with `unevaluatedProperties` applies only to the child values of\ninstance names that do not appear in the `properties`, `patternProperties`,\n`additionalProperties`, or `unevaluatedProperties` annotation results that\napply to the instance location being validated.\n\nFor all such properties, validation succeeds if the child instance\nvalidates against the \"unevaluatedProperties\" schema.\n\nThis means that `properties`, `patternProperties`, `additionalProperties`,\nand all in-place applicators MUST be evaluated before this keyword can be\nevaluated. Authors of extension keywords MUST NOT define an in-place\napplicator that would need to be evaluated before this keyword.\n\nThe annotation result of this keyword is the set of instance property names\nvalidated by this keyword's subschema. Annotation results for\n`unevaluatedProperties` keywords from multiple schemas applied to the same\ninstance location are combined by taking the union of the sets.\n\nOmitting this keyword has the same assertion behavior as an empty schema.\n\nImplementations that do not collect annotations MUST raise an error upon\nencountering this keyword.\n\n[in-place-applicator]: https://json-schema.org/draft/2019-09/json-schema-core.html#in-place",
      "type": "JSONSchema"
    },
    "uniqueItems": {
      "default": false,
      "description": "The value of this keyword MUST be a boolean.\n\nIf this keyword has boolean value `false`, the instance validates\nsuccessfully. If it has boolean value `true`, the instance validates\nsuccessfully if all of its elements are unique.\n\nOmitting this keyword has the same behavior as a value of `false`.",
      "type": "boolean"
    },
    "writeOnly": {
      "default": false,
      "description": "The value of this keyword MUST be a boolean. When multiple occurrences of\nthis keyword is applicable to a single sub-instance, the resulting value\nMUST be `true` if any occurrence specifies a `true` value, and MUST be\n`false` otherwise.\n\nIf `writeOnly` has a value of boolean `true`, it indicates that the value\nis never present when the instance is retrieved from the owning authority.\nIt can be present when sent to the owning authority to update or create the\ndocument (or the resource it represents), but it will not be included in\nany updated or newly created version of the instance.\n\nAn instance document that is marked as `writeOnly` for the entire document\nMAY be returned as a blank document of some sort, or MAY produce an error\nupon retrieval, or have the retrieval request ignored, at the authority's\ndiscretion.\n\nFor example, `writeOnly` would be used to mark a password input field.\n\nThese keywords can be used to assist in user interface instance generation.\nIn particular, an application MAY choose to use a widget that hides input\nvalues as they are typed for write-only fields.",
      "type": "boolean"
    }
  },
  "keywordsByType": {
    "any": {
      "title": "Any",
      "values": [
        "$anchor",
        "$comment",
        "$defs",
        "$id",
        "$recursiveAnchor",
        "$recursiveRef",
        "$ref",
        "$schema",
        "$vocabulary",
        "allOf",
        "anyOf",
        "const",
        "default",
        "definitions",
        "deprecated",
        "description",
        "else",
        "enum",
        "examples",
        "format",
        "if",
        "not",
        "oneOf",
        "readOnly",
        "then",
        "title",
        "type",
        "writeOnly"
      ]
    },
    "array": {
      "title": "Array",
      "values": [
        "additionalItems",
        "contains",
        "items",
        "maxContains",
        "maxItems",
        "minContains",
        "minItems",
        "unevaluatedItems",
        "uniqueItems"
      ]
    },
    "number": {
      "title": "Number",
      "values": [
        "exclusiveMaximum",
        "exclusiveMinimum",
        "maximum",
        "minimum",
        "multipleOf"
      ]
    },
    "object": {
      "title": "Object",
      "values": [
        "additionalProperties",
        "dependencies",
        "dependentRequired",
        "dependentSchemas",
        "maxProperties",
        "minProperties",
        "patternProperties",
        "properties",
        "propertyNames",
        "required",
        "unevaluatedProperties"
      ]
    },
    "string": {
      "title": "String",
      "values": [
        "contentEncoding",
        "contentMediaType",
        "contentSchema",
        "maxLength",
        "minLength",
        "pattern"
      ]
    }
  }
}