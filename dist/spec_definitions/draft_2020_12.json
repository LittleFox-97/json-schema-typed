{
  "$copyright": {
    "credits": [
      "IETF Trust <https://www.ietf.org/>",
      "Austin Wright <aaa@bzfx.net>",
      "Henry Andrews <andrews_henry@yahoo.com>",
      "Ben Hutton <ben@jsonschema.dev>",
      "Greg Dennis <gregsdennis@yahoo.com>"
    ],
    "year": 2020
  },
  "$docsUrl": "https://json-schema.org/draft/2020-12/json-schema-validation.html",
  "$draft": "2020-12",
  "$license": "BSD-2-Clause License\n\nOriginal source code is copyright (c) 2022 Jeremy Rylan\n<https://github.com/jrylan>\n\nDocumentation and keyword descriptions are copyright (c) 2020 IETF Trust <https://www.ietf.org/>, Austin Wright <aaa@bzfx.net>, Henry Andrews <andrews_henry@yahoo.com>, Ben Hutton <ben@jsonschema.dev>, and Greg Dennis <gregsdennis@yahoo.com>. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice,\n   this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice,\n   this list of conditions and the following disclaimer in the documentation\n   and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\nAND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\nIMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\nARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\nLIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\nCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\nSUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\nINTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\nCONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\nARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.",
  "$schemaUrl": "https://json-schema.org/draft/2020-12/schema",
  "enums": {
    "contentEncoding": {
      "description": "Content encoding strategy enum.\n\n- [Content-Transfer-Encoding Syntax](https://datatracker.ietf.org/doc/html/rfc2045#section-6.1)\n- [7bit vs 8bit encoding](https://stackoverflow.com/questions/25710599/content-transfer-encoding-7bit-or-8-bit/28531705#28531705)",
      "title": "ContentEncoding",
      "values": {
        "7bit": {
          "description": "Only US-ASCII characters, which use the lower 7 bits for each character.\n\nEach line must be less than 1,000 characters.",
          "value": "7bit"
        },
        "8bit": {
          "description": "Allow extended ASCII characters which can use the 8th (highest) bit to indicate special characters not available in 7bit.\n\nEach line must be less than 1,000 characters.",
          "value": "8bit"
        },
        "Base64": {
          "description": "Useful for data that is mostly non-text.",
          "value": "base64"
        },
        "Binary": {
          "description": "Same character set as 8bit, with no line length restriction.",
          "value": "binary"
        },
        "IETFToken": {
          "description": "An extension token defined by a standards-track RFC and registered with IANA.",
          "value": "ietf-token"
        },
        "QuotedPrintable": {
          "description": "Lines are limited to 76 characters, and line breaks are represented using special characters that are escaped.",
          "value": "quoted-printable"
        },
        "XToken": {
          "description": "The two characters \"X-\" or \"x-\" followed, with no intervening white space, by any token.",
          "value": "x-token"
        }
      }
    },
    "format": {
      "description": "This enum provides well-known formats that apply to strings.",
      "title": "Format",
      "values": {
        "Date": {
          "description": "A string instance is valid against this attribute if it is a valid representation according to the \"full-date\" production in [RFC 3339][RFC3339].\n\n[RFC3339]: https://datatracker.ietf.org/doc/html/rfc3339",
          "value": "date"
        },
        "DateTime": {
          "description": "A string instance is valid against this attribute if it is a valid representation according to the \"date-time\" production in [RFC 3339][RFC3339].\n\n[RFC3339]: https://datatracker.ietf.org/doc/html/rfc3339",
          "value": "date-time"
        },
        "Duration": {
          "description": "A string instance is valid against this attribute if it is a valid representation according to the \"duration\" production.",
          "value": "duration"
        },
        "Email": {
          "description": "A string instance is valid against this attribute if it is a valid Internet email address as defined by by the \"Mailbox\" ABNF rule in [RFC 5321][RFC5322], section 4.1.2.\n\n[RFC5321]: https://datatracker.ietf.org/doc/html/rfc5321",
          "value": "email"
        },
        "Hostname": {
          "description": "As defined by [RFC 1123, section 2.1][RFC1123], including host names produced using the Punycode algorithm specified in [RFC 5891, section 4.4][RFC5891].\n\n[RFC1123]: https://datatracker.ietf.org/doc/html/rfc1123\n[RFC5891]: https://datatracker.ietf.org/doc/html/rfc5891",
          "value": "hostname"
        },
        "IDNEmail": {
          "description": "A string instance is valid against this attribute if it is a valid Internet email address as defined by the extended \"Mailbox\" ABNF rule in [RFC 6531][RFC6531], section 3.3.\n\n[RFC6531]: https://datatracker.ietf.org/doc/html/rfc6531",
          "value": "idn-email"
        },
        "IDNHostname": {
          "description": "As defined by either [RFC 1123, section 2.1][RFC1123] as for hostname, or an internationalized hostname as defined by [RFC 5890, section 2.3.2.3][RFC5890].\n\n[RFC1123]: https://datatracker.ietf.org/doc/html/rfc1123\n[RFC5890]: https://datatracker.ietf.org/doc/html/rfc5890",
          "value": "idn-hostname"
        },
        "IPv4": {
          "description": "An IPv4 address according to the \"dotted-quad\" ABNF syntax as defined in [RFC 2673, section 3.2][RFC2673].\n\n[RFC2673]: https://datatracker.ietf.org/doc/html/rfc2673",
          "value": "ipv4"
        },
        "IPv6": {
          "description": "An IPv6 address as defined in [RFC 4291, section 2.2][RFC4291].\n\n[RFC4291]: https://datatracker.ietf.org/doc/html/rfc4291",
          "value": "ipv6"
        },
        "IRI": {
          "description": "A string instance is valid against this attribute if it is a valid IRI, according to [RFC 3987][RFC3987].\n\n[RFC3987]: https://datatracker.ietf.org/doc/html/rfc3987",
          "value": "iri"
        },
        "IRIReference": {
          "description": "A string instance is valid against this attribute if it is a valid IRI Reference (either an IRI or a relative-reference), according to [RFC 3987][RFC3987].\n\n[RFC3987]: https://datatracker.ietf.org/doc/html/rfc3987",
          "value": "iri-reference"
        },
        "JSONPointer": {
          "description": "A string instance is valid against this attribute if it is a valid JSON string representation of a JSON Pointer, according to [RFC 6901, section 5][RFC6901].\n\n[RFC6901]: https://datatracker.ietf.org/doc/html/rfc6901",
          "value": "json-pointer"
        },
        "JSONPointerURIFragment": {
          "description": "A string instance is valid against this attribute if it is a valid JSON string representation of a JSON Pointer fragment, according to [RFC 6901, section 5][RFC6901].\n\n[RFC6901]: https://datatracker.ietf.org/doc/html/rfc6901",
          "value": "json-pointer-uri-fragment"
        },
        "RegEx": {
          "description": "This attribute applies to string instances.\n\nA regular expression, which SHOULD be valid according to the [ECMA-262][ecma262] regular expression dialect.\n\nImplementations that validate formats MUST accept at least the subset of [ECMA-262][ecma262] defined in the [Regular Expressions][regexInterop] section of this specification, and SHOULD accept all valid [ECMA-262][ecma262] expressions.\n\n[ecma262]: https://www.ecma-international.org/publications-and-standards/standards/ecma-262/\n[regexInterop]: https://json-schema.org/draft/2020-12/json-schema-validation.html#regexInterop",
          "value": "regex"
        },
        "RelativeJSONPointer": {
          "description": "A string instance is valid against this attribute if it is a valid [Relative JSON Pointer][relative-json-pointer].\n\n[relative-json-pointer]: https://datatracker.ietf.org/doc/html/draft-handrews-relative-json-pointer-01",
          "value": "relative-json-pointer"
        },
        "Time": {
          "description": "A string instance is valid against this attribute if it is a valid representation according to the \"time\" production in [RFC 3339][RFC3339].\n\n[RFC3339]: https://datatracker.ietf.org/doc/html/rfc3339",
          "value": "time"
        },
        "URI": {
          "description": "A string instance is valid against this attribute if it is a valid URI, according to [RFC3986][RFC3986].\n\n[RFC3986]: https://datatracker.ietf.org/doc/html/rfc3986",
          "value": "uri"
        },
        "URIReference": {
          "description": "A string instance is valid against this attribute if it is a valid URI Reference (either a URI or a relative-reference), according to [RFC3986][RFC3986].\n\n[RFC3986]: https://datatracker.ietf.org/doc/html/rfc3986",
          "value": "uri-reference"
        },
        "URITemplate": {
          "description": "A string instance is valid against this attribute if it is a valid URI Template (of any level), according to [RFC 6570][RFC6570].\n\nNote that URI Templates may be used for IRIs; there is no separate IRI Template specification.\n\n[RFC6570]: https://datatracker.ietf.org/doc/html/rfc6570",
          "value": "uri-template"
        },
        "UUID": {
          "description": "A string instance is valid against this attribute if it is a valid string representation of a UUID, according to [RFC 4122][RFC4122].\n\n[RFC4122]: https://datatracker.ietf.org/doc/html/rfc4122",
          "value": "uuid"
        }
      }
    },
    "typeName": {
      "description": "Enum consisting of simple type names for the `type` keyword",
      "title": "TypeName",
      "values": {
        "Array": {
          "description": "Value MUST be an array.",
          "value": "array"
        },
        "Boolean": {
          "description": "Value MUST be a boolean.",
          "value": "boolean"
        },
        "Integer": {
          "description": "Value MUST be an integer, no floating point numbers are allowed. This is a subset of the number type.",
          "value": "integer"
        },
        "Null": {
          "description": "Value MUST be null. Note this is mainly for purpose of being able use union types to define nullability. If this type is not included in a union, null values are not allowed (the primitives listed above do not allow nulls on their own).",
          "value": "null"
        },
        "Number": {
          "description": "Value MUST be a number, floating point numbers are allowed.",
          "value": "number"
        },
        "Object": {
          "description": "Value MUST be an object.",
          "value": "object"
        },
        "String": {
          "description": "Value MUST be a string.",
          "value": "string"
        }
      }
    }
  },
  "keywords": {
    "$anchor": {
      "description": "Using JSON Pointer fragments requires knowledge of the structure of the\nschema. When writing schema documents with the intention to provide\nre-usable schemas, it may be preferable to use a plain name fragment that\nis not tied to any particular structural location. This allows a subschema\nto be relocated without requiring JSON Pointer references to be updated.\n\nThe `$anchor` keyword is used to specify such a fragment. It is an\nidentifier keyword that can only be used to create plain name fragments.\n\nIf present, the value of this keyword MUST be a string, which MUST start\nwith a letter `[A-Za-z]`, followed by any number of letters, digits\n`[0-9]`, hyphens `-`, underscores `_`, colons `:`, or periods `.`.\n\nNote that the anchor string does not include the `#` character, as it is\nnot a URI-reference. An `{\"$anchor\": \"foo\"}` becomes the fragment `#foo`\nwhen used in a URI.\n\nThe base URI to which the resulting fragment is appended is determined by\nthe `$id` keyword as explained in the previous section. Two `$anchor`\nkeywords in the same schema document MAY have the same value if they apply\nto different base URIs, as the resulting full URIs will be distinct.\nHowever, the effect of two `$anchor` keywords with the same value and the\nsame base URI is undefined. Implementations MAY raise an error if such\nusage is detected.",
      "type": "string"
    },
    "$comment": {
      "description": "This keyword reserves a location for comments from schema authors to\nreaders or maintainers of the schema.\n\nThe value of this keyword MUST be a string. Implementations MUST NOT\npresent this string to end users. Tools for editing schemas SHOULD support\ndisplaying and editing this keyword. The value of this keyword MAY be used\nin debug or error output which is intended for developers making use of\nschemas.\n\nSchema vocabularies SHOULD allow `$comment` within any object containing\nvocabulary keywords. Implementations MAY assume `$comment` is allowed\nunless the vocabulary specifically forbids it. Vocabularies MUST NOT\nspecify any effect of `$comment` beyond what is described in this\nspecification.\n\nTools that translate other media types or programming languages to and from\n`application/schema+json` MAY choose to convert that media type or\nprogramming language's native comments to or from `$comment` values. The\nbehavior of such translation when both native comments and `$comment`\nproperties are present is implementation-dependent.\n\nImplementations MAY strip `$comment` values at any point during processing.\nIn particular, this allows for shortening schemas when the size of deployed\nschemas is a concern.\n\nImplementations MUST NOT take any other action based on the presence,\nabsence, or contents of `$comment` properties. In particular, the value of\n`$comment` MUST NOT be collected as an annotation result.",
      "type": "string"
    },
    "$defs": {
      "additionalProperties": {
        "type": "JSONSchema"
      },
      "description": "The `$defs` keyword reserves a location for schema authors to inline\nre-usable JSON Schemas into a more general schema. The keyword does not\ndirectly affect the validation result.\n\nThis keyword's value MUST be an object. Each member value of this object\nMUST be a valid JSON Schema.",
      "type": "object"
    },
    "$dynamicAnchor": {
      "description": "\"The `$dynamicAnchor` indicates that the fragment is an extension point\nwhen used with the `$dynamicRef` keyword. This low-level, advanced feature\nmakes it easier to extend recursive schemas such as the meta-schemas,\nwithout imposing any particular semantics on that extension. See\n`$dynamicRef` for more details.",
      "type": "string"
    },
    "$dynamicRef": {
      "description": "The `$dynamicRef` keyword is an applicator that allows for deferring the\nfull resolution until runtime, at which point it is resolved each time it\nis encountered while evaluating an instance.\n\nTogether with `$dynamicAnchor`, `$dynamicRef` implements a cooperative\nextension mechanism that is primarily useful with recursive schemas\n(schemas that reference themselves). Both the extension point and the\nruntime-determined extension target are defined with `$dynamicAnchor`, and\nonly exhibit runtime dynamic behavior when referenced with `$dynamicRef`.\n\nThe value of the `$dynamicRef` property MUST be a string which is a\nURI-Reference. Resolved against the current URI base, it produces the URI\nused as the starting point for runtime resolution. This initial resolution\nis safe to perform on schema load.\n\nIf the initially resolved starting point URI includes a fragment that was\ncreated by the `$dynamicAnchor` keyword, the initial URI MUST be replaced\nby the URI (including the fragment) for the outermost schema resource in\nthe [dynamic scope][scopes] that defines an identically named fragment with\n`$dynamicAnchor`.\n\nOtherwise, its behavior is identical to `$ref`, and no runtime resolution\nis needed.\n\n[scopes]: https://json-schema.org/draft/2020-12/json-schema-core.html#scopes",
      "format": "uri-reference",
      "type": "string"
    },
    "$id": {
      "description": "The `$id` keyword identifies a schema resource with its\n[canonical][[RFC6596]] URI.\n\nNote that this URI is an identifier and not necessarily a network locator.\nIn the case of a network-addressable URL, a schema need not be downloadable\nfrom its canonical URI.\n\nIf present, the value for this keyword MUST be a string, and MUST represent\na valid [URI-reference][RFC3986]. This URI-reference SHOULD be normalized,\nand MUST resolve to an [absolute-URI][RFC3986] (without a fragment).\nTherefore, `$id` MUST NOT contain a non-empty fragment, and SHOULD NOT\ncontain an empty fragment.\n\nSince an empty fragment in the context of the `application/schema+json`\nmedia type refers to the same resource as the base URI without a fragment,\nan implementation MAY normalize a URI ending with an empty fragment by\nremoving the fragment. However, schema authors SHOULD NOT rely on this\nbehavior across implementations.\n\nThis URI also serves as the base URI for relative URI-references in\nkeywords within the schema resource, in accordance with [RFC 3986][RFC3986]\nsection 5.1.1 regarding base URIs embedded in content.\n\nThe presence of `$id` in a subschema indicates that the subschema\nconstitutes a distinct schema resource within a single schema document.\nFurthermore, in accordance with [RFC 3986][RFC3986] section 5.1.2 regarding\nencapsulating entities, if an `$id` in a subschema is a relative\nURI-reference, the base URI for resolving that reference is the URI of the\nparent schema resource.\n\nIf no parent schema object explicitly identifies itself as a resource with\n`$id`, the base URI is that of the entire document.\n\nThe root schema of a JSON Schema document SHOULD contain an `$id` keyword\nwith an [absolute-URI][RFC3986] (containing a scheme, but no fragment).\n\n[RFC6596]: https://datatracker.ietf.org/doc/html/rfc6596\n[RFC3986]: https://datatracker.ietf.org/doc/html/rfc3986",
      "format": "uri-reference",
      "type": "string"
    },
    "$ref": {
      "description": "The `$ref` keyword is an applicator that is used to reference a statically\nidentified schema. Its results are the results of the referenced schema.\nOther keywords can appear alongside of `$ref` in the same schema object.\n\nThe value of the `$ref` property MUST be a string which is a URI-Reference.\nResolved against the current URI base, it produces the URI of the schema to\napply.",
      "format": "uri-reference",
      "type": "string"
    },
    "$schema": {
      "description": "The `$schema` keyword is both used as a JSON Schema dialect identifier and\nas the identifier of a resource which is itself a JSON Schema, which\ndescribes the set of valid schemas written for this particular dialect.\n\nThe value of this keyword MUST be a [URI][RFC3986] (containing a scheme)\nand this URI MUST be normalized. The current schema MUST be valid against\nthe meta-schema identified by this URI.\n\nIf this URI identifies a retrievable resource, that resource SHOULD be of\nmedia type `application/schema+json`.\n\nThe `$schema` keyword SHOULD be used in the document root schema object,\nand MAY be used in the root schema objects of embedded schema resources. It\nMUST NOT appear in non-resource root schema objects. If absent from the\ndocument root schema, the resulting behavior is implementation-defined.\n\nValues for this property are defined elsewhere in this and other documents,\nand by other parties.\n\n[RFC3986]: https://datatracker.ietf.org/doc/html/rfc3986",
      "format": "uri",
      "type": "string"
    },
    "$vocabulary": {
      "additionalProperties": {
        "format": "uri",
        "type": "string"
      },
      "description": "The `$vocabulary` keyword is used in meta-schemas to identify the\nvocabularies available for use in schemas described by that meta-schema. It\nis also used to indicate whether each vocabulary is required or optional,\nin the sense that an implementation MUST understand the required\nvocabularies in order to successfully process the schema. Together, this\ninformation forms a dialect. Any vocabulary that is understood by the\nimplementation MUST be processed in a manner consistent with the semantic\ndefinitions contained within the vocabulary.\n\nThe value of this keyword MUST be an object. The property names in the\nobject MUST be URIs (containing a scheme) and this URI MUST be normalized.\nEach URI that appears as a property name identifies a specific set of\nkeywords and their semantics.\n\nThe URI MAY be a URL, but the nature of the retrievable resource is\ncurrently undefined, and reserved for future use. Vocabulary authors MAY\nuse the URL of the vocabulary specification, in a human-readable media type\nsuch as `text/html` or `text/plain`, as the vocabulary URI.\n\nThe values of the object properties MUST be booleans. If the value is\n`true`, then implementations that do not recognize the vocabulary MUST\nrefuse to process any schemas that declare this meta-schema with `$schema`.\nIf the value is `false`, implementations that do not recognize the\nvocabulary SHOULD proceed with processing such schemas. The value has no\nimpact if the implementation understands the vocabulary.\n\nUnrecognized keywords SHOULD be ignored. This remains the case for keywords\ndefined by unrecognized vocabularies. It is not currently possible to\ndistinguish between unrecognized keywords that are defined in vocabularies\nfrom those that are not part of any vocabulary.\n\nThe `$vocabulary` keyword SHOULD be used in the root schema of any schema\ndocument intended for use as a meta-schema. It MUST NOT appear in\nsubschemas.\n\nThe `$vocabulary` keyword MUST be ignored in schema documents that are not\nbeing processed as a meta-schema.",
      "type": "object"
    },
    "additionalItems": {
      "deprecated": "`additionalItems` has been deprecated in favor of `prefixItems`\npaired with `items`.",
      "type": "JSONSchema"
    },
    "additionalProperties": {
      "description": "The value of `additionalProperties` MUST be a valid JSON Schema.\n\nThe behavior of this keyword depends on the presence and annotation results\nof `properties` and `patternProperties` within the same schema object.\nValidation with `additionalProperties` applies only to the child values of\ninstance names that do not appear in the annotation results of either\n`properties` or `patternProperties`.\n\nFor all such properties, validation succeeds if the child instance\nvalidates against the `additionalProperties` schema.\n\nThe annotation result of this keyword is the set of instance property names\nvalidated by this keyword's subschema. Annotation results for\n`additionalProperties` keywords from multiple schemas applied to the same\ninstance location are combined by taking the union of the sets.\n\nOmitting this keyword has the same assertion behavior as an empty schema.\n\nImplementations MAY choose to implement or optimize this keyword in another\nway that produces the same effect, such as by directly checking the names\nin `properties` and the patterns in `patternProperties` against the\ninstance property set.",
      "type": "JSONSchema"
    },
    "allOf": {
      "description": "This keyword's value MUST be a non-empty array. Each item of the array MUST\nbe a valid JSON Schema.\n\nAn instance validates successfully against this keyword if it validates\nsuccessfully against all schemas defined by this keyword's value.",
      "items": {
        "type": "JSONSchema<Narrowable>"
      },
      "type": "array"
    },
    "anyOf": {
      "description": "This keyword's value MUST be a non-empty array. Each item of the array MUST\nbe a valid JSON Schema.\n\nAn instance validates successfully against this keyword if it validates\nsuccessfully against at least one schema defined by this keyword's value.",
      "items": {
        "type": "JSONSchema<Narrowable>"
      },
      "type": "array"
    },
    "const": {
      "description": "An instance validates successfully against this keyword if its value is\nequal to the value of the keyword.\n\nUse of this keyword is functionally equivalent to the `enum` keyword with a\nsingle value.",
      "type": "Value"
    },
    "contains": {
      "description": "The value of this keyword MUST be a valid JSON Schema.\n\nAn array instance is valid against `contains` if at least one of its\nelements is valid against the given schema. The subschema MUST be applied\nto every array element even after the first match has been found, in order\nto collect annotations for use by other keywords. This is to ensure that\nall possible annotations are collected.\n\nLogically, the validation result of applying the value subschema to each\nitem in the array MUST be OR'ed with `false`, resulting in an overall\nvalidation result.\n\nThis keyword produces an annotation value which is an array of the indexes\nto which this keyword validates successfully when applying its subschema,\nin ascending order. The value MAY be a boolean `true` if the subschema\nvalidates successfully when applied to every index of the instance. The\nannotation MUST be present if the instance array to which this keyword's\nschema applies is empty.",
      "type": "JSONSchema<Narrowable>"
    },
    "contentEncoding": {
      "description": "If the instance value is a string, this property defines that the string\nSHOULD be interpreted as binary data and decoded using the encoding named\nby this property. [RFC 2045, Sec 6.1][RFC2045] lists the possible values\nfor this property.\n\nThe value of this property SHOULD be ignored if the instance described is\nnot a string.\n\nIf this keyword is absent, but `contentMediaType` is present, this\nindicates that the media type could be encoded into `UTF-8` like any other\nJSON string value, and does not require additional decoding.\n\nThe value of this property MUST be a string.\n\n[RFC2045]: https://datatracker.ietf.org/doc/html/rfc2045#section-6.1",
      "enum": [
        "7bit",
        "8bit",
        "base64",
        "binary",
        "ietf-token",
        "quoted-printable",
        "x-token"
      ],
      "type": "string"
    },
    "contentMediaType": {
      "description": "If the instance is a string, this property indicates the media type of the\ncontents of the string. If `contentEncoding` is present, this property\ndescribes the decoded string.\n\nThe value of this property must be a media type, as defined by\n[RFC 2046][RFC2046]. This property defines the media type of instances\nwhich this schema defines.\n\nThe value of this property SHOULD be ignored if the instance described is\nnot a string.\n\nIf the `contentEncoding` property is not present, but the instance value is\na string, then the value of this property SHOULD specify a text document\ntype, and the character set SHOULD be the character set into which the JSON\nstring value was decoded (for which the default is Unicode).\n\n[RFC2046]: https://datatracker.ietf.org/doc/html/rfc2046",
      "type": "string"
    },
    "contentSchema": {
      "description": "If the instance is a string, and if `contentMediaType` is present, this\nproperty contains a schema which describes the structure of the string.\n\nThis keyword MAY be used with any media type that can be mapped into JSON\nSchema's data model.\n\nThe value of this property MUST be a valid JSON schema. It SHOULD be\nignored if `contentMediaType` is not present.",
      "type": "JSONSchema<Narrowable>"
    },
    "default": {
      "description": "This keyword can be used to supply a default JSON value associated with a\nparticular schema. It is RECOMMENDED that a `default` value be valid\nagainst the associated schema.",
      "type": "Value"
    },
    "definitions": {
      "additionalProperties": {
        "type": "JSONSchema"
      },
      "deprecated": "`definitions` has been renamed to `$defs`.",
      "type": "object"
    },
    "dependencies": {
      "deprecated": "`dependencies` has been split into two keywords:\n`dependentSchemas` and `dependentRequired`.",
      "oneOf": [
        {
          "additionalProperties": {
            "oneOf": [
              {
                "items": {
                  "type": "string"
                },
                "type": "array"
              },
              {
                "type": "JSONSchema"
              }
            ]
          },
          "type": "object"
        }
      ]
    },
    "dependentRequired": {
      "additionalProperties": {
        "items": {
          "type": "string"
        },
        "type": "array"
      },
      "description": "The value of this keyword MUST be an object. Properties in this object, if\nany, MUST be arrays. Elements in each array, if any, MUST be strings, and\nMUST be unique.\n\nThis keyword specifies properties that are required if a specific other\nproperty is present. Their requirement is dependent on the presence of the\nother property.\n\nValidation succeeds if, for each name that appears in both the instance and\nas a name within this keyword's value, every item in the corresponding\narray is also the name of a property in the instance.\n\nOmitting this keyword has the same behavior as an empty object.",
      "type": "object"
    },
    "dependentSchemas": {
      "additionalProperties": {
        "type": "JSONSchema"
      },
      "description": "This keyword specifies subschemas that are evaluated if the instance is an\nobject and contains a certain property.\n\nThis keyword's value MUST be an object. Each value in the object MUST be a\nvalid JSON Schema.\n\nIf the object key is a property in the instance, the entire instance must\nvalidate against the subschema. Its use is dependent on the presence of the\nproperty.\n\nOmitting this keyword has the same behavior as an empty object.",
      "type": "object"
    },
    "deprecated": {
      "description": "The value of this keyword MUST be a boolean. When multiple occurrences of\nthis keyword are applicable to a single sub-instance, applications SHOULD\nconsider the instance location to be deprecated if any occurrence specifies\na `true` value.\n\nIf `deprecated` has a value of boolean `true`, it indicates that\napplications SHOULD refrain from usage of the declared property. It MAY\nmean the property is going to be removed in the future.\n\nA root schema containing `deprecated` with a value of `true` indicates that\nthe entire resource being described MAY be removed in the future.\n\nThe `deprecated` keyword applies to each instance location to which the\nschema object containing the keyword successfully applies. This can result\nin scenarios where every array item or object property is deprecated even\nthough the containing array or object is not.\n\nOmitting this keyword has the same behavior as a value of `false`.",
      "type": "boolean"
    },
    "description": {
      "description": "Can be used to decorate a user interface with explanation or information\nabout the data produced.",
      "type": "string"
    },
    "else": {
      "description": "This keyword's value MUST be a valid JSON Schema.\n\nWhen `if` is present, and the instance fails to validate against its\nsubschema, then validation succeeds against this keyword if the instance\nsuccessfully validates against this keyword's subschema.\n\nThis keyword has no effect when `if` is absent, or when the instance\nsuccessfully validates against its subschema. Implementations MUST NOT\nevaluate the instance against this keyword, for either validation or\nannotation collection purposes, in such cases.",
      "type": "JSONSchema<Narrowable>"
    },
    "enum": {
      "description": "The value of this keyword MUST be an array. This array SHOULD have at least\none element. Elements in the array SHOULD be unique.\n\nAn instance validates successfully against this keyword if its value is\nequal to one of the elements in this keyword's array value.\n\nElements in the array might be of any type, including `null`.",
      "items": {
        "type": "Value"
      },
      "type": "array"
    },
    "examples": {
      "description": "The value of this keyword MUST be an array. When multiple occurrences of\nthis keyword are applicable to a single sub-instance, implementations MUST\nprovide a flat array of all values rather than an array of arrays.\n\nThis keyword can be used to provide sample JSON values associated with a\nparticular schema, for the purpose of illustrating usage. It is RECOMMENDED\nthat these values be valid against the associated schema.\n\nImplementations MAY use the value(s) of `default`, if present, as an\nadditional example. If `examples` is absent, `default` MAY still be used in\nthis manner.",
      "items": {
        "type": "Value"
      },
      "type": "array"
    },
    "exclusiveMaximum": {
      "description": "The value of `exclusiveMaximum` MUST be a number, representing an exclusive\nupper limit for a numeric instance.\n\nIf the instance is a number, then the instance is valid only if it has a\nvalue strictly less than (not equal to) `exclusiveMaximum`.",
      "type": "number"
    },
    "exclusiveMinimum": {
      "description": "The value of `exclusiveMinimum` MUST be a number, representing an exclusive\nlower limit for a numeric instance.\n\nIf the instance is a number, then the instance is valid only if it has a\nvalue strictly greater than (not equal to) `exclusiveMinimum`.",
      "type": "number"
    },
    "format": {
      "description": "Implementations MAY treat `format` as an assertion in addition to an\nannotation, and attempt to validate the value's conformance to the\nspecified semantics.\n\nThe value of this keyword is called a format attribute. It MUST be a\nstring. A format attribute can generally only validate a given set of\ninstance types. If the type of the instance to validate is not in this set,\nvalidation for this format attribute and instance SHOULD succeed. Format\nattributes are most often applied to strings, but can be specified to apply\nto any type.\n\nImplementations MAY support custom format attributes. Save for agreement\nbetween parties, schema authors SHALL NOT expect a peer implementation to\nsupport such custom format attributes. An implementation MUST NOT fail\nvalidation or cease processing due to an unknown format attribute. When\ntreating `format` as an annotation, implementations SHOULD collect both\nknown and unknown format attribute values.",
      "type": "string"
    },
    "if": {
      "description": "This keyword's value MUST be a valid JSON Schema.\n\nThis validation outcome of this keyword's subschema has no direct effect on\nthe overall validation result. Rather, it controls which of the `then` or\n`else` keywords are evaluated.\n\nInstances that successfully validate against this keyword's subschema MUST\nalso be valid against the subschema value of the `then` keyword, if\npresent.\n\nInstances that fail to validate against this keyword's subschema MUST also\nbe valid against the subschema value of the `else` keyword, if present.\n\nIf annotations are being collected, they are collected from this keyword's\nsubschema in the usual way, including when the keyword is present without\neither `then` or `else`.",
      "type": "JSONSchema<Narrowable>"
    },
    "items": {
      "description": "The value of `items` MUST be a valid JSON Schema.\n\nThis keyword applies its subschema to all instance elements at indexes\ngreater than the length of the `prefixItems` array in the same schema\nobject, as reported by the annotation result of that `prefixItems` keyword.\nIf no such annotation result exists, `items` applies its subschema to all\ninstance array elements.\n\nNote that the behavior of `items` without `prefixItems` is identical to\nthat of the schema form of `items` in prior drafts.\n\nWhen `prefixItems` is present, the behavior of `items` is identical to the\nformer `additionalItems` keyword.\n\nIf the `items` subschema is applied to any positions within the instance\narray, it produces an annotation result of boolean `true`, indicating that\nall remaining array elements have been evaluated against this keyword's\nsubschema.\n\nOmitting this keyword has the same assertion behavior as an empty schema.\n\nImplementations MAY choose to implement or optimize this keyword in another\nway that produces the same effect, such as by directly checking for the\npresence and size of a `prefixItems` array.",
      "type": "JSONSchema"
    },
    "maxContains": {
      "description": "The value of this keyword MUST be a non-negative integer.\n\nIf `contains` is not present within the same schema object, then this\nkeyword has no effect.\n\nAn instance array is valid against `maxContains` in two ways, depending on\nthe form of the annotation result of an adjacent `contains` keyword. The\nfirst way is if the annotation result is an array and the length of that\narray is less than or equal to the `maxContains` value. The second way is\nif the annotation result is a boolean `true` and the instance array length\nis less than or equal to the `maxContains` value.",
      "type": "integer"
    },
    "maximum": {
      "description": "The value of `maximum` MUST be a number, representing an inclusive upper\nlimit for a numeric instance.\n\nIf the instance is a number, then this keyword validates only if the\ninstance is less than or exactly equal to `maximum`.",
      "type": "number"
    },
    "maxItems": {
      "description": "The value of this keyword MUST be a non-negative integer.\n\nAn array instance is valid against `maxItems` if its size is less than, or\nequal to, the value of this keyword.",
      "minimum": 0,
      "type": "integer"
    },
    "maxLength": {
      "description": "The value of this keyword MUST be a non-negative integer.\n\nA string instance is valid against this keyword if its length is less than,\nor equal to, the value of this keyword.\n\nThe length of a string instance is defined as the number of its characters\nas defined by [RFC 8259][RFC8259].\n\n[RFC8259]: https://datatracker.ietf.org/doc/html/rfc8259",
      "minimum": 0,
      "type": "integer"
    },
    "maxProperties": {
      "description": "The value of this keyword MUST be a non-negative integer.\n\nAn object instance is valid against `maxProperties` if its number of\n`properties` is less than, or equal to, the value of this keyword.",
      "minimum": 0,
      "type": "integer"
    },
    "minContains": {
      "default": 1,
      "description": "The value of this keyword MUST be a non-negative integer.\n\nIf `contains` is not present within the same schema object, then this\nkeyword has no effect.\n\nAn instance array is valid against `minContains` in two ways, depending on\nthe form of the annotation result of an adjacent `contains` keyword. The\nfirst way is if the annotation result is an array and the length of that\narray is greater than or equal to the `minContains` value. The second way\nis if the annotation result is a boolean `true` and the instance array\nlength is greater than or equal to the `minContains` value.\n\nA value of `0` is allowed, but is only useful for setting a range of\noccurrences from `0` to the value of `maxContains`. A value of `0` with no\n`maxContains` causes `contains` to always pass validation.\n\nOmitting this keyword has the same behavior as a value of `1`.",
      "type": "integer"
    },
    "minimum": {
      "description": "The value of `minimum` MUST be a number, representing an inclusive lower\nlimit for a numeric instance.\n\nIf the instance is a number, then this keyword validates only if the\ninstance is greater than or exactly equal to `minimum`.",
      "type": "number"
    },
    "minItems": {
      "default": 0,
      "description": "The value of this keyword MUST be a non-negative integer.\n\nAn array instance is valid against `minItems` if its size is greater than,\nor equal to, the value of this keyword.\n\nOmitting this keyword has the same behavior as a value of `0`.",
      "minimum": 0,
      "type": "integer"
    },
    "minLength": {
      "default": 0,
      "description": "The value of this keyword MUST be a non-negative integer.\n\nA string instance is valid against this keyword if its length is greater\nthan, or equal to, the value of this keyword.\n\nThe length of a string instance is defined as the number of its characters\nas defined by [RFC 8259][RFC8259].\n\nOmitting this keyword has the same behavior as a value of `0`.\n\n[RFC8259]: https://datatracker.ietf.org/doc/html/rfc8259",
      "minimum": 0,
      "type": "integer"
    },
    "minProperties": {
      "default": 0,
      "description": "The value of this keyword MUST be a non-negative integer.\n\nAn object instance is valid against `minProperties` if its number of\n`properties` is greater than, or equal to, the value of this keyword.\n\nOmitting this keyword has the same behavior as a value of `0`.",
      "minimum": 0,
      "type": "integer"
    },
    "multipleOf": {
      "description": "The value of `multipleOf` MUST be a number, strictly greater than `0`.\n\nA numeric instance is valid only if division by this keyword's value\nresults in an integer.",
      "exclusiveMinimum": 0,
      "type": "number"
    },
    "not": {
      "description": "This keyword's value MUST be a valid JSON Schema.\n\nAn instance is valid against this keyword if it fails to validate\nsuccessfully against the schema defined by this keyword.",
      "type": "JSONSchema<Narrowable>"
    },
    "oneOf": {
      "description": "This keyword's value MUST be a non-empty array. Each item of the array MUST\nbe a valid JSON Schema.\n\nAn instance validates successfully against this keyword if it validates\nsuccessfully against exactly one schema defined by this keyword's value.",
      "items": {
        "type": "JSONSchema<Narrowable>"
      },
      "type": "array"
    },
    "pattern": {
      "description": "The value of this keyword MUST be a string. This string SHOULD be a valid\nregular expression, according to the [ECMA-262][ecma262] regular expression\ndialect.\n\nA string instance is considered valid if the regular expression matches the\ninstance successfully. Recall: regular expressions are not implicitly\nanchored.\n\n[ecma262]: https://www.ecma-international.org/publications-and-standards/standards/ecma-262/",
      "format": "regex",
      "type": "string"
    },
    "patternProperties": {
      "additionalProperties": {
        "type": "JSONSchema"
      },
      "description": "The value of `patternProperties` MUST be an object. Each property name of\nthis object SHOULD be a valid regular expression, according to the\n[ECMA-262][ecma262] regular expression dialect. Each property value of this\nobject MUST be a valid JSON Schema.\n\nValidation succeeds if, for each instance name that matches any regular\nexpressions that appear as a property name in this keyword's value, the\nchild instance for that name successfully validates against each schema\nthat corresponds to a matching regular expression.\n\nThe annotation result of this keyword is the set of instance property names\nmatched by this keyword. Omitting this keyword has the same assertion\nbehavior as an empty object.\n\n[ecma262]: https://www.ecma-international.org/publications-and-standards/standards/ecma-262/",
      "type": "object"
    },
    "prefixItems": {
      "description": "The value of `prefixItems` MUST be a non-empty array of valid JSON Schemas.\n\nValidation succeeds if each element of the instance validates against the\nschema at the same position, if any. This keyword does not constrain the\nlength of the array. If the array is longer than this keyword's value, this\nkeyword validates only the prefix of matching length.\n\nThis keyword produces an annotation value which is the largest index to\nwhich this keyword applied a subschema. The value MAY be a boolean `true`\nif a subschema was applied to every index of the instance, such as is\nproduced by the `items` keyword. This annotation affects the behavior of\n`items` and `unevaluatedItems`.\n\nOmitting this keyword has the same assertion behavior as an empty array.",
      "oneOf": [
        {
          "items": {
            "type": "JSONSchema"
          },
          "type": "array"
        },
        {
          "type": "JSONSchema"
        }
      ]
    },
    "properties": {
      "additionalProperties": {
        "type": "JSONSchema"
      },
      "description": "The value of `properties` MUST be an object. Each value of this object MUST\nbe a valid JSON Schema.\n\nValidation succeeds if, for each name that appears in both the instance and\nas a name within this keyword's value, the child instance for that name\nsuccessfully validates against the corresponding schema.\n\nThe annotation result of this keyword is the set of instance property names\nmatched by this keyword.\n\nOmitting this keyword has the same assertion behavior as an empty object.",
      "type": "object"
    },
    "propertyNames": {
      "description": "The value of `propertyNames` MUST be a valid JSON Schema.\n\nIf the instance is an object, this keyword validates if every property name\nin the instance validates against the provided schema. Note the property\nname that the schema is testing will always be a string.\n\nOmitting this keyword has the same behavior as an empty schema.",
      "type": "JSONSchema"
    },
    "readOnly": {
      "default": false,
      "description": "The value of this keyword MUST be a boolean. When multiple occurrences of\nthis keyword are applicable to a single sub-instance, the resulting value\nMUST be `true` if any occurrence specifies a `true` value, and MUST be\n`false` otherwise.\n\nIf `readOnly` has a value of boolean `true`, it indicates that the value of\nthe instance is managed exclusively by the owning authority, and attempts\nby an application to modify the value of this property are expected to be\nignored or rejected by that owning authority.\n\nAn instance document that is marked as `readOnly` for the entire document\nMAY be ignored if sent to the owning authority, or MAY result in an error,\nat the authority's discretion.\n\nFor example, `readOnly` would be used to mark a database-generated serial\nnumber as read-only.\n\nThis keyword can be used to assist in user interface instance generation.",
      "type": "boolean"
    },
    "required": {
      "description": "The value of this keyword MUST be an array. Elements of this array, if any,\nMUST be strings, and MUST be unique.\n\nAn object instance is valid against this keyword if every item in the array\nis the name of a property in the instance.\n\nOmitting this keyword has the same behavior as an empty array.",
      "items": {
        "type": "string"
      },
      "type": "array"
    },
    "then": {
      "description": "This keyword's value MUST be a valid JSON Schema.\n\nWhen `if` is present, and the instance successfully validates against its\nsubschema, then validation succeeds against this keyword if the instance\nalso successfully validates against this keyword's subschema.\n\nThis keyword has no effect when `if` is absent, or when the instance fails\nto validate against its subschema. Implementations MUST NOT evaluate the\ninstance against this keyword, for either validation or annotation\ncollection purposes, in such cases.",
      "type": "JSONSchema<Narrowable>"
    },
    "title": {
      "description": "Can be used to decorate a user interface with a short label about the data\nproduced.",
      "type": "string"
    },
    "type": {
      "description": "The value of this keyword MUST be either a string or an array. If it is an\narray, elements of the array MUST be strings and MUST be unique.\n\nString values MUST be one of the six primitive types (`\"null\"`,\n`\"boolean\"`, `\"object\"`, `\"array\"`, `\"number\"`, or `\"string\"`), or\n`\"integer\"` which matches any number with a zero fractional part.\n\nAn instance validates if and only if the instance is in any of the sets\nlisted for this keyword.",
      "oneOf": [
        {
          "enum": [
            "array",
            "boolean",
            "integer",
            "null",
            "number",
            "object",
            "string"
          ],
          "type": "string"
        },
        {
          "items": {
            "enum": [
              "array",
              "boolean",
              "integer",
              "null",
              "number",
              "object",
              "string"
            ],
            "type": "string"
          },
          "type": "array"
        }
      ]
    },
    "unevaluatedItems": {
      "description": "The value of `unevaluatedItems` MUST be a valid JSON Schema.\n\nThe behavior of this keyword depends on the annotation results of adjacent\nkeywords that apply to the instance location being validated. Specifically,\nthe annotations from `prefixItems`, `items`, and `contains`, which can come\nfrom those keywords when they are adjacent to the `unevaluatedItems`\nkeyword. Those three annotations, as well as `unevaluatedItems`, can also\nresult from any and all adjacent [in-place applicator][in-place-applicator]\nkeywords.\n\nIf no relevant annotations are present, the `unevaluatedItems` subschema\nMUST be applied to all locations in the array. If a boolean `true` value is\npresent from any of the relevant annotations, `unevaluatedItems` MUST be\nignored. Otherwise, the subschema MUST be applied to any index greater than\nthe largest annotation value for `prefixItems`, which does not appear in\nany annotation value for `contains`.\n\nThis means that `prefixItems`, `items`, `contains`, and all in-place\napplicators MUST be evaluated before this keyword can be evaluated. Authors\nof extension keywords MUST NOT define an in-place applicator that would\nneed to be evaluated after this keyword.\n\nIf the `unevaluatedItems` subschema is applied to any positions within the\ninstance array, it produces an annotation result of boolean `true`,\nanalogous to the behavior of `items`.\n\nOmitting this keyword has the same assertion behavior as an empty schema.\n\n[in-place-applicator]: https://json-schema.org/draft/2020-12/json-schema-core.html#in-place",
      "type": "JSONSchema"
    },
    "unevaluatedProperties": {
      "description": "The value of `unevaluatedProperties` MUST be a valid JSON Schema.\n\nThe behavior of this keyword depends on the annotation results of adjacent\nkeywords that apply to the instance location being validated. Specifically,\nthe annotations from `properties`, `patternProperties`, and\n`additionalProperties`, which can come from those keywords when they are\nadjacent to the `unevaluatedProperties` keyword. Those three annotations,\nas well as `unevaluatedProperties`, can also result from any and all\nadjacent [in-place applicator][in-place-applicator] keywords.\n\nValidation with `unevaluatedProperties` applies only to the child values of\ninstance names that do not appear in the `properties`, `patternProperties`,\n`additionalProperties`, or `unevaluatedProperties` annotation results that\napply to the instance location being validated.\n\nFor all such properties, validation succeeds if the child instance\nvalidates against the \"unevaluatedProperties\" schema.\n\nThis means that `properties`, `patternProperties`, `additionalProperties`,\nand all in-place applicators MUST be evaluated before this keyword can be\nevaluated. Authors of extension keywords MUST NOT define an in-place\napplicator that would need to be evaluated after this keyword.\n\nThe annotation result of this keyword is the set of instance property names\nvalidated by this keyword's subschema.\n\nOmitting this keyword has the same assertion behavior as an empty schema.\n\n[in-place-applicator]: https://json-schema.org/draft/2020-12/json-schema-core.html#in-place",
      "type": "JSONSchema"
    },
    "uniqueItems": {
      "default": false,
      "description": "The value of this keyword MUST be a boolean.\n\nIf this keyword has boolean value `false`, the instance validates\nsuccessfully. If it has boolean value `true`, the instance validates\nsuccessfully if all of its elements are unique.\n\nOmitting this keyword has the same behavior as a value of `false`.",
      "type": "boolean"
    },
    "writeOnly": {
      "default": false,
      "description": "The value of this keyword MUST be a boolean. When multiple occurrences of\nthis keyword is applicable to a single sub-instance, the resulting value\nMUST be `true` if any occurrence specifies a `true` value, and MUST be\n`false` otherwise.\n\nIf `writeOnly` has a value of boolean `true`, it indicates that the value\nis never present when the instance is retrieved from the owning authority.\nIt can be present when sent to the owning authority to update or create the\ndocument (or the resource it represents), but it will not be included in\nany updated or newly created version of the instance.\n\nAn instance document that is marked as `writeOnly` for the entire document\nMAY be returned as a blank document of some sort, or MAY produce an error\nupon retrieval, or have the retrieval request ignored, at the authority's\ndiscretion.\n\nFor example, `writeOnly` would be used to mark a password input field.\n\nThese keywords can be used to assist in user interface instance generation.\nIn particular, an application MAY choose to use a widget that hides input\nvalues as they are typed for write-only fields.",
      "type": "boolean"
    }
  },
  "keywordsByType": {
    "any": {
      "title": "Any",
      "values": [
        "$anchor",
        "$comment",
        "$defs",
        "$dynamicAnchor",
        "$dynamicRef",
        "$id",
        "$ref",
        "$schema",
        "$vocabulary",
        "allOf",
        "anyOf",
        "const",
        "default",
        "definitions",
        "deprecated",
        "description",
        "else",
        "enum",
        "examples",
        "format",
        "if",
        "not",
        "oneOf",
        "readOnly",
        "then",
        "title",
        "type",
        "writeOnly"
      ]
    },
    "array": {
      "title": "Array",
      "values": [
        "additionalItems",
        "contains",
        "items",
        "maxContains",
        "maxItems",
        "minContains",
        "minItems",
        "prefixItems",
        "unevaluatedItems",
        "uniqueItems"
      ]
    },
    "number": {
      "title": "Number",
      "values": [
        "exclusiveMaximum",
        "exclusiveMinimum",
        "maximum",
        "minimum",
        "multipleOf"
      ]
    },
    "object": {
      "title": "Object",
      "values": [
        "additionalProperties",
        "dependencies",
        "dependentRequired",
        "dependentSchemas",
        "maxProperties",
        "minProperties",
        "patternProperties",
        "properties",
        "propertyNames",
        "required",
        "unevaluatedProperties"
      ]
    },
    "string": {
      "title": "String",
      "values": [
        "contentEncoding",
        "contentMediaType",
        "contentSchema",
        "maxLength",
        "minLength",
        "pattern"
      ]
    }
  }
}